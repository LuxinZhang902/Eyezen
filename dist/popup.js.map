{"version":3,"file":"popup.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEtFA;AACA;AACA;AACA;AACA","sources":["webpack://eyezen-chrome-extension/./ui/components/Popup.tsx","webpack://eyezen-chrome-extension/./ui/popup.tsx","webpack://eyezen-chrome-extension/./ui/styles/popup.css","webpack://eyezen-chrome-extension/webpack/bootstrap","webpack://eyezen-chrome-extension/webpack/runtime/chunk loaded","webpack://eyezen-chrome-extension/webpack/runtime/compat get default export","webpack://eyezen-chrome-extension/webpack/runtime/define property getters","webpack://eyezen-chrome-extension/webpack/runtime/ensure chunk","webpack://eyezen-chrome-extension/webpack/runtime/get javascript chunk filename","webpack://eyezen-chrome-extension/webpack/runtime/get mini-css chunk filename","webpack://eyezen-chrome-extension/webpack/runtime/global","webpack://eyezen-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://eyezen-chrome-extension/webpack/runtime/load script","webpack://eyezen-chrome-extension/webpack/runtime/make namespace object","webpack://eyezen-chrome-extension/webpack/runtime/node module decorator","webpack://eyezen-chrome-extension/webpack/runtime/publicPath","webpack://eyezen-chrome-extension/webpack/runtime/jsonp chunk loading","webpack://eyezen-chrome-extension/webpack/before-startup","webpack://eyezen-chrome-extension/webpack/startup","webpack://eyezen-chrome-extension/webpack/after-startup"],"sourcesContent":["import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\n/**\n * Popup Component\n * Main popup interface for the EyeZen Chrome Extension\n */\nimport { useState, useEffect, useRef, lazy, Suspense } from 'react';\nimport { UserStatus, BreakType } from '../../types/index';\nimport { ChromeStorageService } from '../../core/storage/index';\n// Lazy load heavy components\nconst CameraPermissionPopup = lazy(() => import('./CameraPermissionPopup'));\nconst LoginModal = lazy(() => import('./LoginModal'));\n// Lazy load heavy services\nconst loadAIServices = () => Promise.all([\n    import('../../core/api/openai-service').then(m => m.ChromeAIService),\n    import('../../core/coach/index').then(m => m.AICoachService)\n]);\nconst loadMetricsService = () => import('../../core/metrics/index').then(m => m.EyeHealthScorer);\nconst Popup = ({ onStartBreak, onOpenSettings }) => {\n    const lastLogTimeRef = useRef(0);\n    const [state, setState] = useState({\n        status: UserStatus.GOOD,\n        eyeScore: {\n            current: 50,\n            daily: 50,\n            weekly: 50,\n            trend: 'stable'\n        },\n        realtimeScore: -1, // Start with -1 to show placeholder until real data is available\n        isLoading: true,\n        cameraEnabled: true,\n        lastBreakTime: null,\n        streakDays: 0,\n        showCameraPermissionPopup: false,\n        isFeatureRestricted: false,\n        aiRecommendation: 'Analyzing your eye health patterns...',\n        recommendedBreakType: BreakType.MICRO,\n        aiLoading: true,\n        showLoginModal: false,\n        isLoggedIn: false,\n        userEmail: ''\n    });\n    useEffect(() => {\n        console.log('ðŸ”¥ POPUP: useEffect triggered, calling loadUserData');\n        loadUserData();\n        loadLoginState();\n        // Set up periodic updates\n        const interval = setInterval(loadUserData, 30000); // Update every 30 seconds\n        // Set up periodic permission check to detect manual permission changes\n        const permissionCheckInterval = setInterval(checkCameraPermissionStatus, 5000); // Check every 5 seconds\n        // Set up periodic camera state validation\n        const stateValidationInterval = setInterval(() => {\n            validateCameraState();\n        }, 3000); // Check every 3 seconds\n        // Set up message listener for eye metrics from CV worker\n        const messageListener = (message, sender, sendResponse) => {\n            console.log('ðŸ”¥ POPUP: Message received:', message.type, message);\n            if (message.type === 'EYE_METRICS') {\n                console.log('ðŸ”¥ POPUP: EYE_METRICS message received, calling handleEyeMetrics');\n                handleEyeMetrics(message.data);\n            }\n        };\n        if (typeof chrome !== 'undefined' && chrome.runtime) {\n            chrome.runtime.onMessage.addListener(messageListener);\n            // Send a test message to verify message system works\n            setTimeout(() => {\n                console.log('ðŸ§ª POPUP: Sending test message to service worker');\n                chrome.runtime.sendMessage({ type: 'POPUP_TEST', data: 'Hello from popup' }, (response) => {\n                    console.log('ðŸ§ª POPUP: Test message response:', response);\n                });\n            }, 1000);\n            // Fallback: Poll storage for eye metrics in case runtime messages don't work\n            const storagePollingInterval = setInterval(async () => {\n                try {\n                    const result = await chrome.storage.local.get(['latest_eye_metrics']);\n                    if (result.latest_eye_metrics) {\n                        const { data, timestamp } = result.latest_eye_metrics;\n                        // Only process if this is a new metric (within last 5 seconds)\n                        if (Date.now() - timestamp < 5000) {\n                            console.log('ðŸ”„ POPUP: Processing eye metrics from storage fallback:', data);\n                            handleEyeMetrics(data);\n                            // Clear the processed metric to avoid reprocessing\n                            await chrome.storage.local.remove(['latest_eye_metrics']);\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log('ðŸ”„ POPUP: Error polling storage for metrics:', error);\n                }\n            }, 1000); // Check every second\n            // Store the storage polling interval for cleanup\n            window.storagePollingInterval = storagePollingInterval;\n        }\n        return () => {\n            clearInterval(interval);\n            clearInterval(permissionCheckInterval);\n            clearInterval(stateValidationInterval);\n            if (window.storagePollingInterval) {\n                clearInterval(window.storagePollingInterval);\n            }\n            if (typeof chrome !== 'undefined' && chrome.runtime) {\n                chrome.runtime.onMessage.removeListener(messageListener);\n            }\n        };\n        10;\n    }, []);\n    const loadLoginState = async () => {\n        try {\n            if (typeof chrome !== 'undefined' && chrome.storage) {\n                const result = await chrome.storage.local.get(['eyezen_login_state']);\n                const loginState = result.eyezen_login_state;\n                if (loginState && loginState.isLoggedIn) {\n                    setState(prev => ({\n                        ...prev,\n                        isLoggedIn: true,\n                        userEmail: loginState.userEmail\n                    }));\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to load login state:', error);\n        }\n    };\n    const loadUserData = async () => {\n        console.log('ðŸ”¥ POPUP: loadUserData function called');\n        try {\n            let userData = await ChromeStorageService.getUserData();\n            // Initialize storage if no user data exists\n            if (!userData) {\n                await ChromeStorageService.initialize();\n                userData = await ChromeStorageService.getUserData();\n            }\n            if (userData) {\n                // Calculate current eye health score\n                const recentMetrics = userData.metrics.slice(-10);\n                console.log('ðŸ” POPUP: Recent metrics for health score calculation:', recentMetrics.length, recentMetrics);\n                // Lazy load EyeHealthScorer\n                const EyeHealthScorer = await loadMetricsService();\n                const healthScore = EyeHealthScorer.calculateScore(recentMetrics);\n                console.log('ðŸ” POPUP: Calculated health score:', healthScore);\n                // Determine user status based on score and recent metrics\n                const currentStatus = determineUserStatus(healthScore.overall, recentMetrics);\n                // Calculate streak days\n                const streakDays = calculateStreakDays(userData.breaks);\n                // Get last break time\n                const lastBreak = userData.breaks\n                    .filter(b => b.completed)\n                    .sort((a, b) => b.endTime - a.endTime)[0];\n                // Generate AI recommendation\n                const avgFatigue = recentMetrics.reduce((sum, m) => sum + (m.fatigueIndex || 0), 0) / recentMetrics.length;\n                let recommendedType = BreakType.MICRO;\n                let recommendation = 'Take a quick 20-second eye break using the 20-20-20 rule.';\n                if (avgFatigue > 0.7) {\n                    recommendedType = BreakType.LONG;\n                    recommendation = 'High eye strain detected! Take a 15-minute wellness break with TCM massage.';\n                }\n                else if (avgFatigue > 0.4) {\n                    recommendedType = BreakType.SHORT;\n                    recommendation = 'Moderate eye fatigue. A 5-minute guided relaxation break is recommended.';\n                }\n                // Calculate initial real-time score from most recent metrics\n                const mostRecentMetric = recentMetrics[recentMetrics.length - 1];\n                const initialRealtimeScore = mostRecentMetric\n                    ? Math.round(Math.max(0, Math.min(100, 100 - (mostRecentMetric.fatigueIndex * 100))))\n                    : -1; // Use -1 if no recent metrics available\n                // Initialize camera stream flag - do NOT automatically start camera\n                // Camera should only be activated when user explicitly clicks the toggle\n                window.eyeZenCameraStream = null;\n                console.log('ðŸ” POPUP: Setting eyeScore.current to:', healthScore.overall);\n                setState(prev => ({\n                    ...prev,\n                    status: currentStatus,\n                    eyeScore: {\n                        current: healthScore.overall,\n                        daily: healthScore.overall,\n                        weekly: healthScore.overall,\n                        trend: healthScore.trend\n                    },\n                    realtimeScore: initialRealtimeScore,\n                    isLoading: false,\n                    cameraEnabled: userData.settings.cameraEnabled,\n                    lastBreakTime: lastBreak?.endTime || null,\n                    streakDays,\n                    showCameraPermissionPopup: false, // Only show when explicitly triggered\n                    isFeatureRestricted: userData.settings.metricsOnly,\n                    aiRecommendation: recommendation,\n                    recommendedBreakType: recommendedType,\n                    aiLoading: false,\n                    showLoginModal: false\n                    // Preserve existing login state (isLoggedIn, userEmail)\n                }));\n            }\n        }\n        catch (error) {\n            console.error('ðŸ”¥ POPUP: Failed to load user data:', error);\n            console.error('ðŸ”¥ POPUP: Error stack:', error instanceof Error ? error.stack : 'No stack trace');\n            setState((prev) => ({ ...prev, isLoading: false }));\n        }\n    };\n    // Handle eye metrics from CV worker\n    const handleEyeMetrics = async (eyeMetrics) => {\n        try {\n            const timestamp = new Date().toISOString();\n            // Always log when handleEyeMetrics is called for debugging\n            console.log(`ðŸ”¥ [${timestamp}] POPUP: handleEyeMetrics called with:`, eyeMetrics);\n            // Only log face detection occasionally to reduce console noise\n            if (Date.now() - lastLogTimeRef.current > 10000) { // Log every 10 seconds\n                console.log('ðŸ‘¤ Face detected! Received eye metrics:', eyeMetrics);\n                console.log('ðŸ“Š Real-time fatigue index:', eyeMetrics.fatigueIndex, 'Blink rate:', eyeMetrics.blinkRate);\n                lastLogTimeRef.current = Date.now();\n            }\n            // Create properly structured EyeMetrics object\n            const metricsData = {\n                timestamp: Date.now(),\n                blinkRate: eyeMetrics.blinkRate || 0,\n                fatigueIndex: eyeMetrics.fatigueIndex || 0,\n                posture: eyeMetrics.posture || 'unknown',\n                earValue: eyeMetrics.earLeft || eyeMetrics.earRight || 0,\n                perclosValue: eyeMetrics.perclos || 0\n            };\n            // Save metrics to storage\n            await ChromeStorageService.addMetrics(metricsData);\n            // Calculate proper Eye Health score using EyeHealthScorer\n            const recentMetrics = [metricsData]; // Use current metrics for real-time calculation\n            const EyeHealthScorer = await loadMetricsService();\n            const healthScore = EyeHealthScorer.calculateScore(recentMetrics);\n            const newScore = healthScore.overall;\n            const realtimeFatigueScore = Math.max(0, Math.min(100, 100 - (eyeMetrics.fatigueIndex * 100)));\n            const newStatus = determineUserStatus(newScore, [eyeMetrics]);\n            console.log(`ðŸ”¥ [${timestamp}] POPUP: Score calculation:`);\n            console.log(`  - fatigueIndex: ${eyeMetrics.fatigueIndex}`);\n            console.log(`  - Eye Health Score: ${newScore}`);\n            console.log(`  - realtimeFatigueScore: ${realtimeFatigueScore}`);\n            console.log(`  - Health Score Details:`, healthScore);\n            console.log(`  - rounded Eye Health score: ${Math.round(newScore)}`);\n            // Generate AI recommendation based on current metrics\n            let aiRecommendation = 'Your eyes are healthy! Keep up the good work.';\n            let recommendedBreakType = BreakType.MICRO;\n            if (eyeMetrics.fatigueIndex > 0.7) {\n                aiRecommendation = 'High eye strain detected! Take a 15-minute wellness break immediately.';\n                recommendedBreakType = BreakType.LONG;\n            }\n            else if (eyeMetrics.fatigueIndex > 0.4) {\n                aiRecommendation = 'Moderate eye fatigue detected. A 5-minute guided relaxation break is recommended.';\n                recommendedBreakType = BreakType.SHORT;\n            }\n            else if (eyeMetrics.blinkRate < 10) {\n                aiRecommendation = 'Low blink rate detected. Remember to blink more frequently!';\n                recommendedBreakType = BreakType.MICRO;\n            }\n            // Single setState call to avoid race conditions\n            setState(prev => ({\n                ...prev,\n                status: newStatus,\n                eyeScore: {\n                    ...prev.eyeScore,\n                    current: Math.round(newScore)\n                },\n                realtimeScore: Math.round(realtimeFatigueScore),\n                aiRecommendation,\n                recommendedBreakType\n            }));\n            console.log(`ðŸ”¥ [${timestamp}] POPUP: Updated realtimeScore:`, Math.round(realtimeFatigueScore));\n        }\n        catch (error) {\n            console.error('Error handling eye metrics:', error);\n        }\n    };\n    const determineUserStatus = (score, metrics) => {\n        if (score >= 80)\n            return UserStatus.GOOD;\n        if (score >= 60)\n            return UserStatus.TIRED;\n        return UserStatus.CRITICAL;\n    };\n    const calculateStreakDays = (breaks) => {\n        const today = new Date();\n        let streak = 0;\n        for (let i = 0; i < 30; i++) {\n            const checkDate = new Date(today);\n            checkDate.setDate(checkDate.getDate() - i);\n            checkDate.setHours(0, 0, 0, 0);\n            const dayEnd = new Date(checkDate);\n            dayEnd.setHours(23, 59, 59, 999);\n            const dayBreaks = breaks.filter(b => {\n                const breakDate = new Date(b.startTime);\n                return breakDate >= checkDate && breakDate <= dayEnd && b.completed;\n            });\n            if (dayBreaks.length >= 3) { // At least 3 breaks per day\n                streak++;\n            }\n            else if (i === 0) {\n                // If today doesn't have enough breaks, no streak\n                break;\n            }\n            else {\n                // Streak broken\n                break;\n            }\n        }\n        return streak;\n    };\n    const getStatusColor = (status) => {\n        switch (status) {\n            case UserStatus.GOOD:\n                return 'text-green-600';\n            case UserStatus.TIRED:\n                return 'text-yellow-600';\n            case UserStatus.CRITICAL:\n                return 'text-red-600';\n            default:\n                return 'text-gray-600';\n        }\n    };\n    const getStatusIcon = (status) => {\n        switch (status) {\n            case UserStatus.GOOD:\n                return 'ðŸ˜Š';\n            case UserStatus.TIRED:\n                return 'ðŸ˜´';\n            case UserStatus.CRITICAL:\n                return 'ðŸ˜µ';\n            default:\n                return 'ðŸ˜';\n        }\n    };\n    const getScoreColor = (score) => {\n        if (score >= 80)\n            return 'text-green-600';\n        if (score >= 60)\n            return 'text-yellow-600';\n        return 'text-red-600';\n    };\n    const getTrendIcon = (trend) => {\n        switch (trend) {\n            case 'improving':\n                return 'ðŸ“ˆ';\n            case 'declining':\n                return 'ðŸ“‰';\n            default:\n                return 'âž¡ï¸';\n        }\n    };\n    const formatLastBreakTime = (timestamp) => {\n        if (!timestamp)\n            return 'No recent breaks';\n        const now = Date.now();\n        const diff = now - timestamp;\n        const minutes = Math.floor(diff / (1000 * 60));\n        const hours = Math.floor(minutes / 60);\n        if (hours > 0) {\n            return `${hours}h ${minutes % 60}m ago`;\n        }\n        return `${minutes}m ago`;\n    };\n    const handleBreakClick = (breakType) => {\n        onStartBreak(breakType);\n    };\n    const toggleCamera = async () => {\n        try {\n            // Use state.cameraEnabled instead of window flag for more reliable state\n            if (state.cameraEnabled) {\n                await stopCameraStream();\n            }\n            else {\n                // Direct camera access - try to request permission immediately\n                await requestCameraDirectly();\n            }\n        }\n        catch (error) {\n            console.error('Failed to toggle camera:', error);\n        }\n    };\n    const downloadCurrentFrame = async () => {\n        try {\n            if (!state.cameraEnabled) {\n                alert('Camera must be enabled to capture frames');\n                return;\n            }\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'DOWNLOAD_FRAME' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                console.log('ðŸ“¸ Frame downloaded successfully:', response.filename);\n                // Show success feedback\n                alert(`Frame saved as: ${response.filename}`);\n            }\n            else {\n                console.error('âŒ Failed to download frame:', response.error);\n                alert(`Failed to download frame: ${response.error}`);\n            }\n        }\n        catch (error) {\n            console.error('Failed to download frame:', error);\n            alert('Failed to download frame. Please try again.');\n        }\n    };\n    const stopCameraStream = async () => {\n        try {\n            // Stop camera through offscreen document\n            chrome.runtime.sendMessage({ type: 'STOP_CAMERA' }, (response) => {\n                if (chrome.runtime.lastError) {\n                    console.error('âŒ Error stopping camera:', chrome.runtime.lastError.message);\n                    return;\n                }\n                if (response?.success) {\n                    console.log('Camera stopped successfully');\n                }\n            });\n            // Clear camera stream flag\n            window.eyeZenCameraStream = null;\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: false\n            });\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: false,\n                showCameraPermissionPopup: false,\n                realtimeScore: 0 // Reset real-time score when camera is disabled\n            }));\n            console.log('Camera deactivated');\n        }\n        catch (error) {\n            console.error('Failed to stop camera:', error);\n        }\n    };\n    const checkCameraPermissionStatus = async () => {\n        try {\n            // Check if camera permission is still granted\n            const permissionStatus = await navigator.permissions.query({ name: 'camera' });\n            const currentStream = window.eyeZenCameraStream;\n            if (permissionStatus.state === 'denied' && currentStream) {\n                // Permission was revoked but extension still thinks camera is active\n                console.log('Camera permission revoked, updating extension state');\n                // Clear camera stream flag\n                window.eyeZenCameraStream = null;\n                // Update settings and state\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false\n                });\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    showCameraPermissionPopup: false,\n                    realtimeScore: 0 // Reset real-time score when permission is revoked\n                }));\n                // Stop any active camera stream in offscreen document\n                chrome.runtime.sendMessage({ type: 'STOP_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        console.error('âŒ Error stopping camera due to permission revocation:', chrome.runtime.lastError.message);\n                        return;\n                    }\n                    if (response?.success) {\n                        console.log('Camera stopped due to permission revocation');\n                    }\n                });\n            }\n            // Note: We do NOT automatically initialize camera when permission is granted\n            // Camera should only be activated when user explicitly clicks the toggle button\n        }\n        catch (error) {\n            console.log('Could not check camera permission status:', error);\n        }\n    };\n    const validateCameraState = async () => {\n        try {\n            // Query offscreen document for actual camera state\n            chrome.runtime.sendMessage({ type: 'GET_CAMERA_STATE' }, (response) => {\n                if (chrome.runtime.lastError) {\n                    console.error('âŒ Error validating camera state:', chrome.runtime.lastError.message);\n                    return;\n                }\n                if (response && response.isActive !== undefined) {\n                    const offscreenCameraState = response.isActive;\n                    const currentReactState = state.cameraEnabled;\n                    // If states are mismatched, sync them\n                    if (currentReactState !== offscreenCameraState) {\n                        // Update popup state to match offscreen reality\n                        window.eyeZenCameraStream = offscreenCameraState ? true : null;\n                        setState(prev => ({\n                            ...prev,\n                            cameraEnabled: offscreenCameraState\n                        }));\n                        // Update storage settings\n                        ChromeStorageService.updateSettings({\n                            cameraEnabled: offscreenCameraState\n                        });\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.log('Could not validate camera state:', error);\n        }\n    };\n    const initializeCameraStream = async () => {\n        try {\n            // Create offscreen document if it doesn't exist\n            const existingContexts = await chrome.runtime.getContexts({});\n            const offscreenDocument = existingContexts.find((context) => context.contextType === 'OFFSCREEN_DOCUMENT');\n            if (!offscreenDocument) {\n                await chrome.offscreen.createDocument({\n                    url: 'offscreen.html',\n                    reasons: [chrome.offscreen.Reason.USER_MEDIA],\n                    justification: 'Camera access for eye health monitoring'\n                });\n            }\n            // Request camera access through offscreen document\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'REQUEST_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                // Set camera stream flag\n                window.eyeZenCameraStream = true;\n                console.log('Camera stream initialized successfully');\n            }\n            else {\n                window.eyeZenCameraStream = null;\n                console.log('Failed to initialize camera stream:', response.error);\n            }\n        }\n        catch (error) {\n            console.error('Failed to initialize camera stream:', error);\n            window.eyeZenCameraStream = null;\n        }\n    };\n    const requestCameraDirectly = async () => {\n        try {\n            // Show user instruction with better explanation of Chrome extension limitations\n            const userConfirmed = confirm('ðŸ“¹ Camera Permission Setup\\n\\n' +\n                'ðŸ”’ Your privacy is protected - no video is recorded or transmitted, and images are only used for one-time analysis.\\n' +\n                'Continue? (Cancel for timer-only mode)');\n            if (!userConfirmed) {\n                // User cancelled - set to metrics-only mode\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false,\n                    metricsOnly: true\n                });\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    isFeatureRestricted: true\n                }));\n                return;\n            }\n            // Create offscreen document if it doesn't exist\n            const existingContexts = await chrome.runtime.getContexts({});\n            const offscreenDocument = existingContexts.find((context) => context.contextType === 'OFFSCREEN_DOCUMENT');\n            if (!offscreenDocument) {\n                await chrome.offscreen.createDocument({\n                    url: 'offscreen.html',\n                    reasons: [chrome.offscreen.Reason.USER_MEDIA],\n                    justification: 'Camera access for eye health monitoring'\n                });\n            }\n            // Request camera access through offscreen document\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'REQUEST_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                // Update settings to allow camera access\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: true,\n                    metricsOnly: false\n                });\n                // Set camera stream flag\n                window.eyeZenCameraStream = true;\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: true,\n                    showCameraPermissionPopup: false,\n                    isFeatureRestricted: false\n                }));\n                console.log('Camera activated successfully');\n                // Show brief success notification\n                alert(' Success! Camera is now active and AI eye health monitoring is running.');\n            }\n            else {\n                // Handle camera permission denial gracefully\n                console.warn('Camera access denied:', response.error);\n                // Update settings to metrics-only mode\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false,\n                    metricsOnly: true\n                });\n                // Clear camera stream flag\n                window.eyeZenCameraStream = null;\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    showCameraPermissionPopup: false,\n                    isFeatureRestricted: true\n                }));\n                // Show detailed instructions for enabling camera access\n                const message = `${response.error || 'Camera access was denied.'}\n\nðŸ”§ **Why \"Ask\" doesn't work:**\nChrome extension popups close when permission dialogs appear, preventing you from clicking \"Allow\".\n\n**Solution - Set to \"Always Allow\":**\n\n**Method 1 - Chrome Address Bar:**\n1. Look for the camera icon (ðŸŽ¥) in Chrome's address bar\n2. Click it and select \"Always allow\"\n3. Refresh this extension\n\n**Method 2 - Chrome Settings:**\n1. Chrome Settings â†’ Privacy and Security â†’ Site Settings\n2. Click \"Camera\" â†’ find this extension\n3. Change from \"Ask\" to \"Allow\"\n4. Refresh this extension\n\nâœ… You can still use basic timer reminders without camera access.`;\n                alert(message);\n            }\n        }\n        catch (error) {\n            console.error('Failed to request camera access:', error);\n            alert('Failed to request camera access. Please try again.');\n        }\n    };\n    const handleCameraPermissionApprove = async () => {\n        try {\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: true,\n                metricsOnly: false\n            });\n            // Set a flag to indicate camera stream should be active\n            // The actual stream is managed by the offscreen document\n            window.eyeZenCameraStream = true;\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: true,\n                showCameraPermissionPopup: false,\n                isFeatureRestricted: false\n            }));\n        }\n        catch (error) {\n            console.error('Failed to approve camera access:', error);\n        }\n    };\n    const handleCameraPermissionReject = async () => {\n        try {\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: false,\n                metricsOnly: true\n            });\n            // Clear camera stream flag\n            window.eyeZenCameraStream = null;\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: false,\n                showCameraPermissionPopup: false,\n                isFeatureRestricted: true\n            }));\n        }\n        catch (error) {\n            console.error('Failed to reject camera access:', error);\n        }\n    };\n    const handleLogin = async (email, password) => {\n        console.log('Login attempt:', { email });\n        try {\n            // Simulate API delay\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            // Get registered users from storage\n            const result = await chrome.storage.local.get(['eyezen_users']);\n            const users = result.eyezen_users || {};\n            // Check if user exists\n            if (!users[email]) {\n                throw new Error('No account found with this email address. Please sign up first.');\n            }\n            // Verify password\n            if (users[email].password !== password) {\n                throw new Error('Incorrect password. Please try again.');\n            }\n            // Successful login\n            setState(prev => ({\n                ...prev,\n                isLoggedIn: true,\n                userEmail: email,\n                showLoginModal: false\n            }));\n            // Store login state in Chrome storage\n            await chrome.storage.local.set({\n                'eyezen_login_state': {\n                    isLoggedIn: true,\n                    userEmail: email,\n                    loginTime: Date.now()\n                }\n            });\n        }\n        catch (error) {\n            // Re-throw the error to be handled by LoginModal\n            throw error;\n        }\n    };\n    const handleSignup = async (email, password, name) => {\n        console.log('Signup attempt:', { email, name });\n        try {\n            // Simulate API delay\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            // Get existing users from storage\n            const result = await chrome.storage.local.get(['eyezen_users']);\n            const users = result.eyezen_users || {};\n            // Check if user already exists\n            if (users[email]) {\n                throw new Error('An account with this email already exists. Please login instead.');\n            }\n            // Validate email format\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                throw new Error('Please enter a valid email address.');\n            }\n            // Validate password strength\n            if (password.length < 6) {\n                throw new Error('Password must be at least 6 characters long.');\n            }\n            // Create new user\n            const newUser = {\n                email,\n                password,\n                name,\n                createdAt: Date.now(),\n                verified: true // Set to true after email verification\n            };\n            // Store user in users database\n            users[email] = newUser;\n            await chrome.storage.local.set({ 'eyezen_users': users });\n            // Successful signup - log them in\n            setState(prev => ({\n                ...prev,\n                isLoggedIn: true,\n                userEmail: email,\n                showLoginModal: false\n            }));\n            // Store login state\n            await chrome.storage.local.set({\n                'eyezen_login_state': {\n                    isLoggedIn: true,\n                    userEmail: email,\n                    loginTime: Date.now()\n                }\n            });\n        }\n        catch (error) {\n            // Re-throw the error to be handled by LoginModal\n            throw error;\n        }\n    };\n    if (state.isLoading) {\n        return (_jsx(\"div\", { className: \"w-[380px] h-[550px] bg-white flex items-center justify-center\", children: _jsxs(\"div\", { className: \"text-center\", children: [_jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4\" }), _jsx(\"p\", { className: \"text-gray-600\", children: \"Loading EyeZen...\" })] }) }));\n    }\n    return (_jsxs(_Fragment, { children: [state.showCameraPermissionPopup && (_jsx(Suspense, { fallback: _jsx(\"div\", { className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\", children: _jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-white\" }) }), children: _jsx(CameraPermissionPopup, { isVisible: state.showCameraPermissionPopup, onApprove: handleCameraPermissionApprove, onReject: handleCameraPermissionReject, onClose: () => setState(prev => ({ ...prev, showCameraPermissionPopup: false })) }) })), _jsx(Suspense, { fallback: _jsx(\"div\", { className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\", children: _jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-white\" }) }), children: _jsx(LoginModal, { isVisible: state.showLoginModal, onClose: () => setState(prev => ({ ...prev, showLoginModal: false })), onLogin: handleLogin, onSignup: handleSignup }) }), _jsxs(\"div\", { className: \"w-[380px] h-[550px] bg-white overflow-hidden flex flex-col relative\", children: [_jsxs(\"div\", { className: \"bg-gradient-to-r from-green-600 to-emerald-600 text-white p-4\", children: [_jsxs(\"div\", { className: \"flex items-center justify-between mb-3\", children: [_jsxs(\"div\", { className: \"flex items-center space-x-3\", children: [_jsx(\"div\", { className: \"text-2xl\", children: \"\\uD83D\\uDC41\\uFE0F\" }), _jsxs(\"div\", { children: [_jsx(\"h1\", { className: \"text-lg font-bold\", children: \"EyeZen\" }), _jsx(\"p\", { className: \"text-blue-100 text-xs opacity-90\", children: \"Eye Health Monitor\" })] })] }), state.isLoggedIn ? (_jsxs(\"div\", { className: \"flex items-center space-x-2\", children: [_jsx(\"span\", { className: \"text-xs text-blue-100 opacity-90 truncate max-w-20\", children: state.userEmail.split('@')[0] }), _jsx(\"button\", { onClick: async () => {\n                                                    await chrome.storage.local.remove(['eyezen_login_state']);\n                                                    setState(prev => ({ ...prev, isLoggedIn: false, userEmail: '' }));\n                                                }, className: \"p-1 hover:bg-white/20 rounded transition-colors\", title: \"Logout\", children: _jsx(\"svg\", { className: \"w-3 h-3\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: _jsx(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1\" }) }) })] })) : (_jsx(\"button\", { onClick: () => setState(prev => ({ ...prev, showLoginModal: true })), className: \"p-2 hover:bg-white/20 rounded-lg transition-colors\", title: \"Login\", children: _jsx(\"svg\", { className: \"w-4 h-4\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: _jsx(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\" }) }) }))] }), _jsx(\"div\", { className: \"bg-white/10 backdrop-blur-sm rounded-lg p-3 border border-white/20\", children: _jsxs(\"div\", { className: \"flex items-center justify-between\", children: [_jsxs(\"div\", { className: \"flex items-center space-x-3\", children: [_jsx(\"div\", { className: \"text-lg\", children: \"\\uD83D\\uDCF9\" }), _jsxs(\"div\", { className: \"flex-1\", children: [_jsx(\"div\", { className: \"font-semibold text-sm\", children: \"Camera Monitoring\" }), _jsx(\"div\", { className: \"text-xs text-blue-100 opacity-90\", children: state.cameraEnabled ? 'Active - Tracking eye health' : 'Inactive - Click to enable' }), !state.cameraEnabled && (_jsx(\"button\", { onClick: () => setState(prev => ({ ...prev, showCameraPermissionPopup: true })), className: \"text-xs text-blue-200 hover:text-white underline mt-1 transition-colors\", children: \"Need help? View setup guide\" })), state.cameraEnabled && (_jsxs(\"button\", { onClick: downloadCurrentFrame, className: \"text-xs text-blue-200 hover:text-white underline mt-1 transition-colors flex items-center space-x-1\", children: [_jsx(\"span\", { children: \"\\uD83D\\uDCF8\" }), _jsx(\"span\", { children: \"Download Current Frame\" })] }))] })] }), _jsx(\"button\", { onClick: toggleCamera, className: `relative inline-flex h-6 w-11 items-center rounded-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-white/50 ${state.cameraEnabled ? 'bg-green-500 shadow-lg' : 'bg-white/30'}`, children: _jsx(\"span\", { className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-md ${state.cameraEnabled ? 'translate-x-6' : 'translate-x-1'}` }) })] }) })] }), _jsx(\"div\", { className: \"p-3 relative\", children: _jsx(\"div\", { className: \"text-center mb-3\", children: _jsxs(\"div\", { className: \"bg-gradient-to-r from-blue-50 to-green-50 rounded-lg p-3 mx-1 mb-2 border border-gray-100 shadow-sm\", children: [_jsxs(\"div\", { className: \"flex items-center justify-between mb-2\", children: [_jsxs(\"div\", { className: \"flex items-center\", children: [_jsx(\"span\", { className: \"text-lg mr-2\", children: state.eyeScore.current >= 80 ? 'ðŸ˜Š' : state.eyeScore.current >= 60 ? 'ðŸ˜' : state.eyeScore.current >= 40 ? 'ðŸ˜Ÿ' : 'ðŸ˜µ' }), _jsx(\"h2\", { className: \"text-sm font-semibold text-gray-800\", children: \"Eye Health Score\" })] }), _jsxs(\"div\", { className: \"flex items-center\", children: [_jsx(\"span\", { className: `text-xl font-bold ${getScoreColor(state.eyeScore.current)}`, children: state.eyeScore.current }), _jsx(\"span\", { className: \"text-sm text-gray-500 ml-1\", children: \"/100\" }), state.cameraEnabled && state.eyeScore.current === 50 && (_jsxs(\"span\", { className: \"ml-2 text-xs text-blue-600 font-medium flex items-center\", children: [_jsx(\"span\", { className: \"animate-spin mr-1\", children: \"\\uD83D\\uDD04\" }), \"Analyzing...\"] }))] })] }), _jsx(\"div\", { className: \"w-full bg-gray-200 rounded-full h-1.5 mb-2\", children: _jsx(\"div\", { className: `h-1.5 rounded-full transition-all duration-500 ${getScoreColor(state.eyeScore.current).includes('green') ? 'bg-green-500' : getScoreColor(state.eyeScore.current).includes('yellow') ? 'bg-yellow-500' : 'bg-red-500'}`, style: { width: `${state.eyeScore.current}%` } }) }), _jsx(\"div\", { className: \"text-xs text-gray-500 text-center mb-2\", children: \"Based on eye strain, posture, fatigue levels\" }), _jsx(\"div\", { className: \"mt-3\", children: _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.MICRO), className: \"w-full px-4 py-3 bg-gradient-to-r from-green-500 to-emerald-500 text-white rounded-lg hover:from-green-400 hover:to-emerald-400 transition-all duration-200 font-medium flex items-center justify-center space-x-2 text-sm\", children: [_jsx(\"span\", { children: \"\\u26A1\" }), _jsx(\"span\", { children: \"Start Recommended Break with AI\" })] }) })] }) }) }), _jsxs(\"div\", { className: \"px-4 pb-4 flex-1\", children: [_jsxs(\"div\", { children: [_jsx(\"h3\", { className: \"font-semibold text-gray-700 mb-2\", children: \"Choose Your Break\" }), _jsxs(\"div\", { className: \"grid grid-cols-3 gap-2\", children: [_jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.MICRO), className: \"p-3 bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-lg transition-colors duration-200 text-center border border-blue-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\u26A1\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Quick\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"20 sec\" })] }), _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.SHORT), className: \"p-3 bg-green-50 hover:bg-green-100 text-green-700 rounded-lg transition-colors duration-200 text-center border border-green-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\uD83E\\uDDD8\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Eye Break\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"5 min\" })] }), _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.LONG), className: \"p-3 bg-purple-50 hover:bg-purple-100 text-purple-700 rounded-lg transition-colors duration-200 text-center border border-purple-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\uD83D\\uDC86\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Wellness\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"15 min\" })] })] })] }), _jsx(\"button\", { onClick: onOpenSettings, className: \"w-full mt-4 py-2 text-sm text-gray-600 hover:text-gray-800 transition-colors\", children: \"View detailed dashboard \\u2192\" })] })] })] }));\n};\nexport default Popup;\n","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createRoot } from 'react-dom/client';\nimport Popup from './components/Popup';\nimport './styles/popup.css';\n// Initialize popup when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    const container = document.getElementById('popup-root');\n    if (!container) {\n        console.error('Popup root element not found');\n        return;\n    }\n    const root = createRoot(container);\n    const handleStartBreak = (breakType) => {\n        // Send message to background script to start break\n        chrome.runtime.sendMessage({\n            action: 'START_BREAK',\n            breakType: breakType\n        }, (response) => {\n            if (response?.success) {\n                // Close popup after starting break\n                window.close();\n            }\n            else {\n                console.error('Failed to start break:', response?.error);\n            }\n        });\n    };\n    const handleOpenSettings = () => {\n        // Open options page (dashboard)\n        chrome.runtime.openOptionsPage();\n        window.close();\n    };\n    root.render(_jsx(Popup, { onStartBreak: handleStartBreak, onOpenSettings: handleOpenSettings }));\n});\n// Handle any runtime errors\nwindow.addEventListener('error', (event) => {\n    console.error('Popup error:', event.error);\n});\nwindow.addEventListener('unhandledrejection', (event) => {\n    console.error('Popup unhandled promise rejection:', event.reason);\n});\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"eyezen-chrome-extension:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"popup\": 0,\n\t\"ui_styles_popup_css\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(\"ui_styles_popup_css\" != chunkId) {\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkeyezen_chrome_extension\"] = self[\"webpackChunkeyezen_chrome_extension\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"core_storage_index_ts\",\"ui_styles_popup_css\"], () => (__webpack_require__(\"./ui/popup.tsx\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}