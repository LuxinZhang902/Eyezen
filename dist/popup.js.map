{"version":3,"file":"popup.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEtFA;AACA;AACA;AACA;AACA","sources":["webpack://eyezen-chrome-extension/./ui/components/Popup.tsx","webpack://eyezen-chrome-extension/./ui/popup.tsx","webpack://eyezen-chrome-extension/./ui/styles/popup.css","webpack://eyezen-chrome-extension/webpack/bootstrap","webpack://eyezen-chrome-extension/webpack/runtime/chunk loaded","webpack://eyezen-chrome-extension/webpack/runtime/compat get default export","webpack://eyezen-chrome-extension/webpack/runtime/define property getters","webpack://eyezen-chrome-extension/webpack/runtime/ensure chunk","webpack://eyezen-chrome-extension/webpack/runtime/get javascript chunk filename","webpack://eyezen-chrome-extension/webpack/runtime/get mini-css chunk filename","webpack://eyezen-chrome-extension/webpack/runtime/global","webpack://eyezen-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://eyezen-chrome-extension/webpack/runtime/load script","webpack://eyezen-chrome-extension/webpack/runtime/make namespace object","webpack://eyezen-chrome-extension/webpack/runtime/node module decorator","webpack://eyezen-chrome-extension/webpack/runtime/publicPath","webpack://eyezen-chrome-extension/webpack/runtime/jsonp chunk loading","webpack://eyezen-chrome-extension/webpack/before-startup","webpack://eyezen-chrome-extension/webpack/startup","webpack://eyezen-chrome-extension/webpack/after-startup"],"sourcesContent":["import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\n/**\n * Popup Component\n * Main popup interface for the EyeZen Chrome Extension\n */\nimport { useState, useEffect, useRef, lazy, Suspense } from 'react';\nimport { UserStatus, BreakType } from '../../types/index';\nimport { ChromeStorageService } from '../../core/storage/index';\n// Lazy load heavy components\nconst CameraPermissionPopup = lazy(() => import('./CameraPermissionPopup'));\nconst LoginModal = lazy(() => import('./LoginModal'));\n// Lazy load heavy services\nconst loadAIServices = () => Promise.all([\n    import('../../core/api/openai-service').then(m => m.ChromeAIService),\n    import('../../core/coach/index').then(m => m.AICoachService)\n]);\nconst loadMetricsService = () => import('../../core/metrics/index').then(m => m.EyeHealthScorer);\nconst Popup = ({ onStartBreak, onOpenSettings }) => {\n    const lastLogTimeRef = useRef(0);\n    const [state, setState] = useState({\n        status: UserStatus.GOOD,\n        eyeScore: {\n            current: 50,\n            daily: 50,\n            weekly: 50,\n            trend: 'stable'\n        },\n        realtimeScore: -1, // Start with -1 to show placeholder until real data is available\n        isLoading: true,\n        cameraEnabled: true,\n        lastBreakTime: null,\n        streakDays: 0,\n        showCameraPermissionPopup: false,\n        isFeatureRestricted: false,\n        aiRecommendation: 'Analyzing your eye health patterns...',\n        recommendedBreakType: BreakType.MICRO,\n        aiLoading: true,\n        showLoginModal: false,\n        isLoggedIn: false,\n        userEmail: ''\n    });\n    useEffect(() => {\n        console.log('🔥 POPUP: useEffect triggered, calling loadUserData');\n        loadUserData();\n        loadLoginState();\n        // Set up periodic updates\n        const interval = setInterval(loadUserData, 30000); // Update every 30 seconds\n        // Set up periodic permission check to detect manual permission changes\n        const permissionCheckInterval = setInterval(checkCameraPermissionStatus, 5000); // Check every 5 seconds\n        // Set up periodic camera state validation\n        const stateValidationInterval = setInterval(() => {\n            validateCameraState();\n        }, 3000); // Check every 3 seconds\n        // Set up message listener for eye metrics from CV worker\n        const messageListener = (message, sender, sendResponse) => {\n            console.log('🔥 POPUP: Message received:', message.type, message);\n            if (message.type === 'EYE_METRICS') {\n                console.log('🔥 POPUP: EYE_METRICS message received, calling handleEyeMetrics');\n                handleEyeMetrics(message.data);\n            }\n        };\n        if (typeof chrome !== 'undefined' && chrome.runtime) {\n            chrome.runtime.onMessage.addListener(messageListener);\n            // Send a test message to verify message system works\n            setTimeout(() => {\n                console.log('🧪 POPUP: Sending test message to service worker');\n                chrome.runtime.sendMessage({ type: 'POPUP_TEST', data: 'Hello from popup' }, (response) => {\n                    console.log('🧪 POPUP: Test message response:', response);\n                });\n            }, 1000);\n            // Fallback: Poll storage for eye metrics in case runtime messages don't work\n            const storagePollingInterval = setInterval(async () => {\n                try {\n                    const result = await chrome.storage.local.get(['latest_eye_metrics']);\n                    if (result.latest_eye_metrics) {\n                        const { data, timestamp } = result.latest_eye_metrics;\n                        // Only process if this is a new metric (within last 5 seconds)\n                        if (Date.now() - timestamp < 5000) {\n                            console.log('🔄 POPUP: Processing eye metrics from storage fallback:', data);\n                            handleEyeMetrics(data);\n                            // Clear the processed metric to avoid reprocessing\n                            await chrome.storage.local.remove(['latest_eye_metrics']);\n                        }\n                    }\n                }\n                catch (error) {\n                    console.log('🔄 POPUP: Error polling storage for metrics:', error);\n                }\n            }, 1000); // Check every second\n            // Store the storage polling interval for cleanup\n            window.storagePollingInterval = storagePollingInterval;\n        }\n        return () => {\n            clearInterval(interval);\n            clearInterval(permissionCheckInterval);\n            clearInterval(stateValidationInterval);\n            if (window.storagePollingInterval) {\n                clearInterval(window.storagePollingInterval);\n            }\n            if (typeof chrome !== 'undefined' && chrome.runtime) {\n                chrome.runtime.onMessage.removeListener(messageListener);\n            }\n        };\n        10;\n    }, []);\n    const loadLoginState = async () => {\n        try {\n            if (typeof chrome !== 'undefined' && chrome.storage) {\n                const result = await chrome.storage.local.get(['eyezen_login_state']);\n                const loginState = result.eyezen_login_state;\n                if (loginState && loginState.isLoggedIn) {\n                    setState(prev => ({\n                        ...prev,\n                        isLoggedIn: true,\n                        userEmail: loginState.userEmail\n                    }));\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to load login state:', error);\n        }\n    };\n    const loadUserData = async () => {\n        console.log('🔥 POPUP: loadUserData function called');\n        try {\n            let userData = await ChromeStorageService.getUserData();\n            // Initialize storage if no user data exists\n            if (!userData) {\n                await ChromeStorageService.initialize();\n                userData = await ChromeStorageService.getUserData();\n            }\n            if (userData) {\n                // Calculate current eye health score\n                const recentMetrics = userData.metrics.slice(-10);\n                console.log('🔍 POPUP: Recent metrics for health score calculation:', recentMetrics.length, recentMetrics);\n                // Lazy load EyeHealthScorer\n                const EyeHealthScorer = await loadMetricsService();\n                const healthScore = EyeHealthScorer.calculateScore(recentMetrics);\n                console.log('🔍 POPUP: Calculated health score:', healthScore);\n                // Determine user status based on score and recent metrics\n                const currentStatus = determineUserStatus(healthScore.overall, recentMetrics);\n                // Calculate streak days\n                const streakDays = calculateStreakDays(userData.breaks);\n                // Get last break time\n                const lastBreak = userData.breaks\n                    .filter(b => b.completed)\n                    .sort((a, b) => b.endTime - a.endTime)[0];\n                // Generate AI recommendation\n                const avgFatigue = recentMetrics.reduce((sum, m) => sum + (m.fatigueIndex || 0), 0) / recentMetrics.length;\n                let recommendedType = BreakType.MICRO;\n                let recommendation = 'Take a quick 20-second eye break using the 20-20-20 rule.';\n                if (avgFatigue > 0.7) {\n                    recommendedType = BreakType.LONG;\n                    recommendation = 'High eye strain detected! Take a 15-minute wellness break with TCM massage.';\n                }\n                else if (avgFatigue > 0.4) {\n                    recommendedType = BreakType.SHORT;\n                    recommendation = 'Moderate eye fatigue. A 5-minute guided relaxation break is recommended.';\n                }\n                // Calculate initial real-time score from most recent metrics\n                const mostRecentMetric = recentMetrics[recentMetrics.length - 1];\n                const initialRealtimeScore = mostRecentMetric\n                    ? Math.round(Math.max(0, Math.min(100, 100 - (mostRecentMetric.fatigueIndex * 100))))\n                    : -1; // Use -1 if no recent metrics available\n                // Initialize camera stream flag - do NOT automatically start camera\n                // Camera should only be activated when user explicitly clicks the toggle\n                window.eyeZenCameraStream = null;\n                console.log('🔍 POPUP: Setting eyeScore.current to:', healthScore.overall);\n                setState(prev => ({\n                    ...prev,\n                    status: currentStatus,\n                    eyeScore: {\n                        current: healthScore.overall,\n                        daily: healthScore.overall,\n                        weekly: healthScore.overall,\n                        trend: healthScore.trend\n                    },\n                    realtimeScore: initialRealtimeScore,\n                    isLoading: false,\n                    cameraEnabled: userData.settings.cameraEnabled,\n                    lastBreakTime: lastBreak?.endTime || null,\n                    streakDays,\n                    showCameraPermissionPopup: false, // Only show when explicitly triggered\n                    isFeatureRestricted: userData.settings.metricsOnly,\n                    aiRecommendation: recommendation,\n                    recommendedBreakType: recommendedType,\n                    aiLoading: false,\n                    showLoginModal: false\n                    // Preserve existing login state (isLoggedIn, userEmail)\n                }));\n            }\n        }\n        catch (error) {\n            console.error('🔥 POPUP: Failed to load user data:', error);\n            console.error('🔥 POPUP: Error stack:', error instanceof Error ? error.stack : 'No stack trace');\n            setState((prev) => ({ ...prev, isLoading: false }));\n        }\n    };\n    // Handle eye metrics from CV worker\n    const handleEyeMetrics = async (eyeMetrics) => {\n        try {\n            const timestamp = new Date().toISOString();\n            // Always log when handleEyeMetrics is called for debugging\n            console.log(`🔥 [${timestamp}] POPUP: handleEyeMetrics called with:`, eyeMetrics);\n            // Only log face detection occasionally to reduce console noise\n            if (Date.now() - lastLogTimeRef.current > 10000) { // Log every 10 seconds\n                console.log('👤 Face detected! Received eye metrics:', eyeMetrics);\n                console.log('📊 Real-time fatigue index:', eyeMetrics.fatigueIndex, 'Blink rate:', eyeMetrics.blinkRate);\n                lastLogTimeRef.current = Date.now();\n            }\n            // Create properly structured EyeMetrics object\n            const metricsData = {\n                timestamp: Date.now(),\n                blinkRate: eyeMetrics.blinkRate || 0,\n                fatigueIndex: eyeMetrics.fatigueIndex || 0,\n                posture: eyeMetrics.posture || 'unknown',\n                earValue: eyeMetrics.earLeft || eyeMetrics.earRight || 0,\n                perclosValue: eyeMetrics.perclos || 0\n            };\n            // Save metrics to storage\n            await ChromeStorageService.addMetrics(metricsData);\n            // Calculate proper Eye Health score using EyeHealthScorer\n            const recentMetrics = [metricsData]; // Use current metrics for real-time calculation\n            const EyeHealthScorer = await loadMetricsService();\n            const healthScore = EyeHealthScorer.calculateScore(recentMetrics);\n            const newScore = healthScore.overall;\n            const realtimeFatigueScore = Math.max(0, Math.min(100, 100 - (eyeMetrics.fatigueIndex * 100)));\n            const newStatus = determineUserStatus(newScore, [eyeMetrics]);\n            console.log(`🔥 [${timestamp}] POPUP: Score calculation:`);\n            console.log(`  - fatigueIndex: ${eyeMetrics.fatigueIndex}`);\n            console.log(`  - Eye Health Score: ${newScore}`);\n            console.log(`  - realtimeFatigueScore: ${realtimeFatigueScore}`);\n            console.log(`  - Health Score Details:`, healthScore);\n            console.log(`  - rounded Eye Health score: ${Math.round(newScore)}`);\n            // Generate AI recommendation based on current metrics\n            let aiRecommendation = 'Your eyes are healthy! Keep up the good work.';\n            let recommendedBreakType = BreakType.MICRO;\n            if (eyeMetrics.fatigueIndex > 0.7) {\n                aiRecommendation = 'High eye strain detected! Take a 15-minute wellness break immediately.';\n                recommendedBreakType = BreakType.LONG;\n            }\n            else if (eyeMetrics.fatigueIndex > 0.4) {\n                aiRecommendation = 'Moderate eye fatigue detected. A 5-minute guided relaxation break is recommended.';\n                recommendedBreakType = BreakType.SHORT;\n            }\n            else if (eyeMetrics.blinkRate < 10) {\n                aiRecommendation = 'Low blink rate detected. Remember to blink more frequently!';\n                recommendedBreakType = BreakType.MICRO;\n            }\n            // Single setState call to avoid race conditions\n            setState(prev => ({\n                ...prev,\n                status: newStatus,\n                eyeScore: {\n                    ...prev.eyeScore,\n                    current: Math.round(newScore)\n                },\n                realtimeScore: Math.round(realtimeFatigueScore),\n                aiRecommendation,\n                recommendedBreakType\n            }));\n            console.log(`🔥 [${timestamp}] POPUP: Updated realtimeScore:`, Math.round(realtimeFatigueScore));\n        }\n        catch (error) {\n            console.error('Error handling eye metrics:', error);\n        }\n    };\n    const determineUserStatus = (score, metrics) => {\n        if (score >= 80)\n            return UserStatus.GOOD;\n        if (score >= 60)\n            return UserStatus.TIRED;\n        return UserStatus.CRITICAL;\n    };\n    const calculateStreakDays = (breaks) => {\n        const today = new Date();\n        let streak = 0;\n        for (let i = 0; i < 30; i++) {\n            const checkDate = new Date(today);\n            checkDate.setDate(checkDate.getDate() - i);\n            checkDate.setHours(0, 0, 0, 0);\n            const dayEnd = new Date(checkDate);\n            dayEnd.setHours(23, 59, 59, 999);\n            const dayBreaks = breaks.filter(b => {\n                const breakDate = new Date(b.startTime);\n                return breakDate >= checkDate && breakDate <= dayEnd && b.completed;\n            });\n            if (dayBreaks.length >= 3) { // At least 3 breaks per day\n                streak++;\n            }\n            else if (i === 0) {\n                // If today doesn't have enough breaks, no streak\n                break;\n            }\n            else {\n                // Streak broken\n                break;\n            }\n        }\n        return streak;\n    };\n    const getStatusColor = (status) => {\n        switch (status) {\n            case UserStatus.GOOD:\n                return 'text-green-600';\n            case UserStatus.TIRED:\n                return 'text-yellow-600';\n            case UserStatus.CRITICAL:\n                return 'text-red-600';\n            default:\n                return 'text-gray-600';\n        }\n    };\n    const getStatusIcon = (status) => {\n        switch (status) {\n            case UserStatus.GOOD:\n                return '😊';\n            case UserStatus.TIRED:\n                return '😴';\n            case UserStatus.CRITICAL:\n                return '😵';\n            default:\n                return '😐';\n        }\n    };\n    const getScoreColor = (score) => {\n        if (score >= 80)\n            return 'text-green-600';\n        if (score >= 60)\n            return 'text-yellow-600';\n        return 'text-red-600';\n    };\n    const getTrendIcon = (trend) => {\n        switch (trend) {\n            case 'improving':\n                return '📈';\n            case 'declining':\n                return '📉';\n            default:\n                return '➡️';\n        }\n    };\n    const formatLastBreakTime = (timestamp) => {\n        if (!timestamp)\n            return 'No recent breaks';\n        const now = Date.now();\n        const diff = now - timestamp;\n        const minutes = Math.floor(diff / (1000 * 60));\n        const hours = Math.floor(minutes / 60);\n        if (hours > 0) {\n            return `${hours}h ${minutes % 60}m ago`;\n        }\n        return `${minutes}m ago`;\n    };\n    const handleBreakClick = (breakType) => {\n        onStartBreak(breakType);\n    };\n    const toggleCamera = async () => {\n        try {\n            // Use state.cameraEnabled instead of window flag for more reliable state\n            if (state.cameraEnabled) {\n                await stopCameraStream();\n            }\n            else {\n                // Direct camera access - try to request permission immediately\n                await requestCameraDirectly();\n            }\n        }\n        catch (error) {\n            console.error('Failed to toggle camera:', error);\n        }\n    };\n    const downloadCurrentFrame = async () => {\n        try {\n            if (!state.cameraEnabled) {\n                alert('Camera must be enabled to capture frames');\n                return;\n            }\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'DOWNLOAD_FRAME' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                console.log('📸 Frame downloaded successfully:', response.filename);\n                // Show success feedback\n                alert(`Frame saved as: ${response.filename}`);\n            }\n            else {\n                console.error('❌ Failed to download frame:', response.error);\n                alert(`Failed to download frame: ${response.error}`);\n            }\n        }\n        catch (error) {\n            console.error('Failed to download frame:', error);\n            alert('Failed to download frame. Please try again.');\n        }\n    };\n    const stopCameraStream = async () => {\n        try {\n            // Stop camera through offscreen document\n            chrome.runtime.sendMessage({ type: 'STOP_CAMERA' }, (response) => {\n                if (chrome.runtime.lastError) {\n                    console.error('❌ Error stopping camera:', chrome.runtime.lastError.message);\n                    return;\n                }\n                if (response?.success) {\n                    console.log('Camera stopped successfully');\n                }\n            });\n            // Clear camera stream flag\n            window.eyeZenCameraStream = null;\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: false\n            });\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: false,\n                showCameraPermissionPopup: false,\n                realtimeScore: 0 // Reset real-time score when camera is disabled\n            }));\n            console.log('Camera deactivated');\n        }\n        catch (error) {\n            console.error('Failed to stop camera:', error);\n        }\n    };\n    const checkCameraPermissionStatus = async () => {\n        try {\n            // Check if camera permission is still granted\n            const permissionStatus = await navigator.permissions.query({ name: 'camera' });\n            const currentStream = window.eyeZenCameraStream;\n            if (permissionStatus.state === 'denied' && currentStream) {\n                // Permission was revoked but extension still thinks camera is active\n                console.log('Camera permission revoked, updating extension state');\n                // Clear camera stream flag\n                window.eyeZenCameraStream = null;\n                // Update settings and state\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false\n                });\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    showCameraPermissionPopup: false,\n                    realtimeScore: 0 // Reset real-time score when permission is revoked\n                }));\n                // Stop any active camera stream in offscreen document\n                chrome.runtime.sendMessage({ type: 'STOP_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        console.error('❌ Error stopping camera due to permission revocation:', chrome.runtime.lastError.message);\n                        return;\n                    }\n                    if (response?.success) {\n                        console.log('Camera stopped due to permission revocation');\n                    }\n                });\n            }\n            // Note: We do NOT automatically initialize camera when permission is granted\n            // Camera should only be activated when user explicitly clicks the toggle button\n        }\n        catch (error) {\n            console.log('Could not check camera permission status:', error);\n        }\n    };\n    const validateCameraState = async () => {\n        try {\n            // Query offscreen document for actual camera state\n            chrome.runtime.sendMessage({ type: 'GET_CAMERA_STATE' }, (response) => {\n                if (chrome.runtime.lastError) {\n                    console.error('❌ Error validating camera state:', chrome.runtime.lastError.message);\n                    return;\n                }\n                if (response && response.isActive !== undefined) {\n                    const offscreenCameraState = response.isActive;\n                    const currentReactState = state.cameraEnabled;\n                    // If states are mismatched, sync them\n                    if (currentReactState !== offscreenCameraState) {\n                        // Update popup state to match offscreen reality\n                        window.eyeZenCameraStream = offscreenCameraState ? true : null;\n                        setState(prev => ({\n                            ...prev,\n                            cameraEnabled: offscreenCameraState\n                        }));\n                        // Update storage settings\n                        ChromeStorageService.updateSettings({\n                            cameraEnabled: offscreenCameraState\n                        });\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.log('Could not validate camera state:', error);\n        }\n    };\n    const initializeCameraStream = async () => {\n        try {\n            // Create offscreen document if it doesn't exist\n            const existingContexts = await chrome.runtime.getContexts({});\n            const offscreenDocument = existingContexts.find((context) => context.contextType === 'OFFSCREEN_DOCUMENT');\n            if (!offscreenDocument) {\n                await chrome.offscreen.createDocument({\n                    url: 'offscreen.html',\n                    reasons: [chrome.offscreen.Reason.USER_MEDIA],\n                    justification: 'Camera access for eye health monitoring'\n                });\n            }\n            // Request camera access through offscreen document\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'REQUEST_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                // Set camera stream flag\n                window.eyeZenCameraStream = true;\n                console.log('Camera stream initialized successfully');\n            }\n            else {\n                window.eyeZenCameraStream = null;\n                console.log('Failed to initialize camera stream:', response.error);\n            }\n        }\n        catch (error) {\n            console.error('Failed to initialize camera stream:', error);\n            window.eyeZenCameraStream = null;\n        }\n    };\n    const requestCameraDirectly = async () => {\n        try {\n            // Show user instruction with better explanation of Chrome extension limitations\n            const userConfirmed = confirm('📹 Camera Permission Setup\\n\\n' +\n                '🔒 Your privacy is protected - no video is recorded or transmitted, and images are only used for one-time analysis.\\n' +\n                'Continue? (Cancel for timer-only mode)');\n            if (!userConfirmed) {\n                // User cancelled - set to metrics-only mode\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false,\n                    metricsOnly: true\n                });\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    isFeatureRestricted: true\n                }));\n                return;\n            }\n            // Create offscreen document if it doesn't exist\n            const existingContexts = await chrome.runtime.getContexts({});\n            const offscreenDocument = existingContexts.find((context) => context.contextType === 'OFFSCREEN_DOCUMENT');\n            if (!offscreenDocument) {\n                await chrome.offscreen.createDocument({\n                    url: 'offscreen.html',\n                    reasons: [chrome.offscreen.Reason.USER_MEDIA],\n                    justification: 'Camera access for eye health monitoring'\n                });\n            }\n            // Request camera access through offscreen document\n            const response = await new Promise((resolve, reject) => {\n                chrome.runtime.sendMessage({ type: 'REQUEST_CAMERA' }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                        return;\n                    }\n                    if (!response) {\n                        reject(new Error('No response received from offscreen document'));\n                        return;\n                    }\n                    resolve(response);\n                });\n            });\n            if (response.success) {\n                // Update settings to allow camera access\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: true,\n                    metricsOnly: false\n                });\n                // Set camera stream flag\n                window.eyeZenCameraStream = true;\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: true,\n                    showCameraPermissionPopup: false,\n                    isFeatureRestricted: false\n                }));\n                console.log('Camera activated successfully');\n                // Show brief success notification\n                alert(' Success! Camera is now active and AI eye health monitoring is running.');\n            }\n            else {\n                // Handle camera permission denial gracefully\n                console.warn('Camera access denied:', response.error);\n                // Update settings to metrics-only mode\n                await ChromeStorageService.updateSettings({\n                    cameraEnabled: false,\n                    metricsOnly: true\n                });\n                // Clear camera stream flag\n                window.eyeZenCameraStream = null;\n                setState(prev => ({\n                    ...prev,\n                    cameraEnabled: false,\n                    showCameraPermissionPopup: false,\n                    isFeatureRestricted: true\n                }));\n                // Show detailed instructions for enabling camera access\n                const message = `${response.error || 'Camera access was denied.'}\n\n🔧 **Why \"Ask\" doesn't work:**\nChrome extension popups close when permission dialogs appear, preventing you from clicking \"Allow\".\n\n**Solution - Set to \"Always Allow\":**\n\n**Method 1 - Chrome Address Bar:**\n1. Look for the camera icon (🎥) in Chrome's address bar\n2. Click it and select \"Always allow\"\n3. Refresh this extension\n\n**Method 2 - Chrome Settings:**\n1. Chrome Settings → Privacy and Security → Site Settings\n2. Click \"Camera\" → find this extension\n3. Change from \"Ask\" to \"Allow\"\n4. Refresh this extension\n\n✅ You can still use basic timer reminders without camera access.`;\n                alert(message);\n            }\n        }\n        catch (error) {\n            console.error('Failed to request camera access:', error);\n            alert('Failed to request camera access. Please try again.');\n        }\n    };\n    const handleCameraPermissionApprove = async () => {\n        try {\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: true,\n                metricsOnly: false\n            });\n            // Set a flag to indicate camera stream should be active\n            // The actual stream is managed by the offscreen document\n            window.eyeZenCameraStream = true;\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: true,\n                showCameraPermissionPopup: false,\n                isFeatureRestricted: false\n            }));\n        }\n        catch (error) {\n            console.error('Failed to approve camera access:', error);\n        }\n    };\n    const handleCameraPermissionReject = async () => {\n        try {\n            await ChromeStorageService.updateSettings({\n                cameraEnabled: false,\n                metricsOnly: true\n            });\n            // Clear camera stream flag\n            window.eyeZenCameraStream = null;\n            setState(prev => ({\n                ...prev,\n                cameraEnabled: false,\n                showCameraPermissionPopup: false,\n                isFeatureRestricted: true\n            }));\n        }\n        catch (error) {\n            console.error('Failed to reject camera access:', error);\n        }\n    };\n    const handleLogin = async (email, password) => {\n        console.log('Login attempt:', { email });\n        try {\n            // Simulate API delay\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            // Get registered users from storage\n            const result = await chrome.storage.local.get(['eyezen_users']);\n            const users = result.eyezen_users || {};\n            // Check if user exists\n            if (!users[email]) {\n                throw new Error('No account found with this email address. Please sign up first.');\n            }\n            // Verify password\n            if (users[email].password !== password) {\n                throw new Error('Incorrect password. Please try again.');\n            }\n            // Successful login\n            setState(prev => ({\n                ...prev,\n                isLoggedIn: true,\n                userEmail: email,\n                showLoginModal: false\n            }));\n            // Store login state in Chrome storage\n            await chrome.storage.local.set({\n                'eyezen_login_state': {\n                    isLoggedIn: true,\n                    userEmail: email,\n                    loginTime: Date.now()\n                }\n            });\n        }\n        catch (error) {\n            // Re-throw the error to be handled by LoginModal\n            throw error;\n        }\n    };\n    const handleSignup = async (email, password, name) => {\n        console.log('Signup attempt:', { email, name });\n        try {\n            // Simulate API delay\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            // Get existing users from storage\n            const result = await chrome.storage.local.get(['eyezen_users']);\n            const users = result.eyezen_users || {};\n            // Check if user already exists\n            if (users[email]) {\n                throw new Error('An account with this email already exists. Please login instead.');\n            }\n            // Validate email format\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                throw new Error('Please enter a valid email address.');\n            }\n            // Validate password strength\n            if (password.length < 6) {\n                throw new Error('Password must be at least 6 characters long.');\n            }\n            // Create new user\n            const newUser = {\n                email,\n                password,\n                name,\n                createdAt: Date.now(),\n                verified: true // Set to true after email verification\n            };\n            // Store user in users database\n            users[email] = newUser;\n            await chrome.storage.local.set({ 'eyezen_users': users });\n            // Successful signup - log them in\n            setState(prev => ({\n                ...prev,\n                isLoggedIn: true,\n                userEmail: email,\n                showLoginModal: false\n            }));\n            // Store login state\n            await chrome.storage.local.set({\n                'eyezen_login_state': {\n                    isLoggedIn: true,\n                    userEmail: email,\n                    loginTime: Date.now()\n                }\n            });\n        }\n        catch (error) {\n            // Re-throw the error to be handled by LoginModal\n            throw error;\n        }\n    };\n    if (state.isLoading) {\n        return (_jsx(\"div\", { className: \"w-[380px] h-[550px] bg-white flex items-center justify-center\", children: _jsxs(\"div\", { className: \"text-center\", children: [_jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4\" }), _jsx(\"p\", { className: \"text-gray-600\", children: \"Loading EyeZen...\" })] }) }));\n    }\n    return (_jsxs(_Fragment, { children: [state.showCameraPermissionPopup && (_jsx(Suspense, { fallback: _jsx(\"div\", { className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\", children: _jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-white\" }) }), children: _jsx(CameraPermissionPopup, { isVisible: state.showCameraPermissionPopup, onApprove: handleCameraPermissionApprove, onReject: handleCameraPermissionReject, onClose: () => setState(prev => ({ ...prev, showCameraPermissionPopup: false })) }) })), _jsx(Suspense, { fallback: _jsx(\"div\", { className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\", children: _jsx(\"div\", { className: \"animate-spin rounded-full h-8 w-8 border-b-2 border-white\" }) }), children: _jsx(LoginModal, { isVisible: state.showLoginModal, onClose: () => setState(prev => ({ ...prev, showLoginModal: false })), onLogin: handleLogin, onSignup: handleSignup }) }), _jsxs(\"div\", { className: \"w-[380px] h-[550px] bg-white overflow-hidden flex flex-col relative\", children: [_jsxs(\"div\", { className: \"bg-gradient-to-r from-green-600 to-emerald-600 text-white p-4\", children: [_jsxs(\"div\", { className: \"flex items-center justify-between mb-3\", children: [_jsxs(\"div\", { className: \"flex items-center space-x-3\", children: [_jsx(\"div\", { className: \"text-2xl\", children: \"\\uD83D\\uDC41\\uFE0F\" }), _jsxs(\"div\", { children: [_jsx(\"h1\", { className: \"text-lg font-bold\", children: \"EyeZen\" }), _jsx(\"p\", { className: \"text-blue-100 text-xs opacity-90\", children: \"Eye Health Monitor\" })] })] }), state.isLoggedIn ? (_jsxs(\"div\", { className: \"flex items-center space-x-2\", children: [_jsx(\"span\", { className: \"text-xs text-blue-100 opacity-90 truncate max-w-20\", children: state.userEmail.split('@')[0] }), _jsx(\"button\", { onClick: async () => {\n                                                    await chrome.storage.local.remove(['eyezen_login_state']);\n                                                    setState(prev => ({ ...prev, isLoggedIn: false, userEmail: '' }));\n                                                }, className: \"p-1 hover:bg-white/20 rounded transition-colors\", title: \"Logout\", children: _jsx(\"svg\", { className: \"w-3 h-3\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: _jsx(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1\" }) }) })] })) : (_jsx(\"button\", { onClick: () => setState(prev => ({ ...prev, showLoginModal: true })), className: \"p-2 hover:bg-white/20 rounded-lg transition-colors\", title: \"Login\", children: _jsx(\"svg\", { className: \"w-4 h-4\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: _jsx(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 2, d: \"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\" }) }) }))] }), _jsx(\"div\", { className: \"bg-white/10 backdrop-blur-sm rounded-lg p-3 border border-white/20\", children: _jsxs(\"div\", { className: \"flex items-center justify-between\", children: [_jsxs(\"div\", { className: \"flex items-center space-x-3\", children: [_jsx(\"div\", { className: \"text-lg\", children: \"\\uD83D\\uDCF9\" }), _jsxs(\"div\", { className: \"flex-1\", children: [_jsx(\"div\", { className: \"font-semibold text-sm\", children: \"Camera Monitoring\" }), _jsx(\"div\", { className: \"text-xs text-blue-100 opacity-90\", children: state.cameraEnabled ? 'Active - Tracking eye health' : 'Inactive - Click to enable' }), !state.cameraEnabled && (_jsx(\"button\", { onClick: () => setState(prev => ({ ...prev, showCameraPermissionPopup: true })), className: \"text-xs text-blue-200 hover:text-white underline mt-1 transition-colors\", children: \"Need help? View setup guide\" })), state.cameraEnabled && (_jsxs(\"button\", { onClick: downloadCurrentFrame, className: \"text-xs text-blue-200 hover:text-white underline mt-1 transition-colors flex items-center space-x-1\", children: [_jsx(\"span\", { children: \"\\uD83D\\uDCF8\" }), _jsx(\"span\", { children: \"Download Current Frame\" })] }))] })] }), _jsx(\"button\", { onClick: toggleCamera, className: `relative inline-flex h-6 w-11 items-center rounded-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-white/50 ${state.cameraEnabled ? 'bg-green-500 shadow-lg' : 'bg-white/30'}`, children: _jsx(\"span\", { className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200 shadow-md ${state.cameraEnabled ? 'translate-x-6' : 'translate-x-1'}` }) })] }) })] }), _jsx(\"div\", { className: \"p-3 relative\", children: _jsx(\"div\", { className: \"text-center mb-3\", children: _jsxs(\"div\", { className: \"bg-gradient-to-r from-blue-50 to-green-50 rounded-lg p-3 mx-1 mb-2 border border-gray-100 shadow-sm\", children: [_jsxs(\"div\", { className: \"flex items-center justify-between mb-2\", children: [_jsxs(\"div\", { className: \"flex items-center\", children: [_jsx(\"span\", { className: \"text-lg mr-2\", children: state.eyeScore.current >= 80 ? '😊' : state.eyeScore.current >= 60 ? '😐' : state.eyeScore.current >= 40 ? '😟' : '😵' }), _jsx(\"h2\", { className: \"text-sm font-semibold text-gray-800\", children: \"Eye Health Score\" })] }), _jsxs(\"div\", { className: \"flex items-center\", children: [_jsx(\"span\", { className: `text-xl font-bold ${getScoreColor(state.eyeScore.current)}`, children: state.eyeScore.current }), _jsx(\"span\", { className: \"text-sm text-gray-500 ml-1\", children: \"/100\" }), state.cameraEnabled && state.eyeScore.current === 50 && (_jsxs(\"span\", { className: \"ml-2 text-xs text-blue-600 font-medium flex items-center\", children: [_jsx(\"span\", { className: \"animate-spin mr-1\", children: \"\\uD83D\\uDD04\" }), \"Analyzing...\"] }))] })] }), _jsx(\"div\", { className: \"w-full bg-gray-200 rounded-full h-1.5 mb-2\", children: _jsx(\"div\", { className: `h-1.5 rounded-full transition-all duration-500 ${getScoreColor(state.eyeScore.current).includes('green') ? 'bg-green-500' : getScoreColor(state.eyeScore.current).includes('yellow') ? 'bg-yellow-500' : 'bg-red-500'}`, style: { width: `${state.eyeScore.current}%` } }) }), _jsx(\"div\", { className: \"text-xs text-gray-500 text-center mb-2\", children: \"Based on eye strain, posture, fatigue levels\" }), _jsx(\"div\", { className: \"mt-3\", children: _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.MICRO), className: \"w-full px-4 py-3 bg-gradient-to-r from-green-500 to-emerald-500 text-white rounded-lg hover:from-green-400 hover:to-emerald-400 transition-all duration-200 font-medium flex items-center justify-center space-x-2 text-sm\", children: [_jsx(\"span\", { children: \"\\u26A1\" }), _jsx(\"span\", { children: \"Start Recommended Break with AI\" })] }) })] }) }) }), _jsxs(\"div\", { className: \"px-4 pb-4 flex-1\", children: [_jsxs(\"div\", { children: [_jsx(\"h3\", { className: \"font-semibold text-gray-700 mb-2\", children: \"Choose Your Break\" }), _jsxs(\"div\", { className: \"grid grid-cols-3 gap-2\", children: [_jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.MICRO), className: \"p-3 bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-lg transition-colors duration-200 text-center border border-blue-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\u26A1\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Quick\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"20 sec\" })] }), _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.SHORT), className: \"p-3 bg-green-50 hover:bg-green-100 text-green-700 rounded-lg transition-colors duration-200 text-center border border-green-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\uD83E\\uDDD8\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Eye Break\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"5 min\" })] }), _jsxs(\"button\", { onClick: () => handleBreakClick(BreakType.LONG), className: \"p-3 bg-purple-50 hover:bg-purple-100 text-purple-700 rounded-lg transition-colors duration-200 text-center border border-purple-200\", children: [_jsx(\"div\", { className: \"text-xl mb-1\", children: \"\\uD83D\\uDC86\" }), _jsx(\"div\", { className: \"text-xs font-medium\", children: \"Wellness\" }), _jsx(\"div\", { className: \"text-xs opacity-70\", children: \"15 min\" })] })] })] }), _jsx(\"button\", { onClick: onOpenSettings, className: \"w-full mt-4 py-2 text-sm text-gray-600 hover:text-gray-800 transition-colors\", children: \"View detailed dashboard \\u2192\" })] })] })] }));\n};\nexport default Popup;\n","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createRoot } from 'react-dom/client';\nimport Popup from './components/Popup';\nimport './styles/popup.css';\n// Initialize popup when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    const container = document.getElementById('popup-root');\n    if (!container) {\n        console.error('Popup root element not found');\n        return;\n    }\n    const root = createRoot(container);\n    const handleStartBreak = (breakType) => {\n        // Send message to background script to start break\n        chrome.runtime.sendMessage({\n            action: 'START_BREAK',\n            breakType: breakType\n        }, (response) => {\n            if (response?.success) {\n                // Close popup after starting break\n                window.close();\n            }\n            else {\n                console.error('Failed to start break:', response?.error);\n            }\n        });\n    };\n    const handleOpenSettings = () => {\n        // Open options page (dashboard)\n        chrome.runtime.openOptionsPage();\n        window.close();\n    };\n    root.render(_jsx(Popup, { onStartBreak: handleStartBreak, onOpenSettings: handleOpenSettings }));\n});\n// Handle any runtime errors\nwindow.addEventListener('error', (event) => {\n    console.error('Popup error:', event.error);\n});\nwindow.addEventListener('unhandledrejection', (event) => {\n    console.error('Popup unhandled promise rejection:', event.reason);\n});\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"eyezen-chrome-extension:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"popup\": 0,\n\t\"ui_styles_popup_css\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(\"ui_styles_popup_css\" != chunkId) {\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkeyezen_chrome_extension\"] = self[\"webpackChunkeyezen_chrome_extension\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"core_storage_index_ts\",\"ui_styles_popup_css\"], () => (__webpack_require__(\"./ui/popup.tsx\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}