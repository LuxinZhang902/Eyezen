{"version":3,"file":"core_metrics_index_ts.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://eyezen-chrome-extension/./core/metrics/index.ts"],"sourcesContent":["/**\n * Core Metrics Module\n * Handles eye health calculations, scoring, and data aggregation\n */\n/**\n * Eye Health Scoring System\n * Calculates a comprehensive score (0-100) based on multiple factors\n */\nexport class EyeHealthScorer {\n    /**\n     * Calculate overall eye health score with base score approach\n     */\n    static calculateScore(metrics) {\n        if (metrics.length === 0) {\n            return {\n                overall: 50,\n                components: {\n                    eyeStrain: 50,\n                    blinkHealth: 50,\n                    postureHealth: 50,\n                    fatigueLevel: 50\n                },\n                trend: 'stable',\n                recommendations: ['Start monitoring your eye health']\n            };\n        }\n        const latest = metrics[metrics.length - 1];\n        const avgMetrics = this.calculateAverages(metrics.slice(-10)); // Last 10 readings\n        const eyeStrainScore = this.calculateEyeStrainScore(avgMetrics.earValue, avgMetrics.perclosValue);\n        const blinkHealthScore = this.calculateBlinkHealthScore(avgMetrics.blinkRate);\n        const postureScore = this.calculatePostureScore(latest.posture);\n        // fatigueIndex is already on 0-100 scale, so we invert it (lower fatigue = higher score)\n        const fatigueScore = Math.max(0, Math.min(100, 100 - avgMetrics.fatigueIndex));\n        console.log('🔍 EyeHealthScorer: Component scores:', {\n            eyeStrainScore,\n            blinkHealthScore,\n            postureScore,\n            fatigueScore,\n            avgMetrics,\n            latest: latest.posture\n        });\n        // Base score approach: Start with 50 and add weighted improvements\n        const BASE_SCORE = 50;\n        const maxPossibleScore = 100;\n        const improvementRange = maxPossibleScore - BASE_SCORE; // 50 points to distribute\n        const weightedImprovement = (eyeStrainScore / 100) * (this.WEIGHTS.EAR + this.WEIGHTS.PERCLOS) * improvementRange +\n            (postureScore / 100) * this.WEIGHTS.POSTURE * improvementRange +\n            (fatigueScore / 100) * this.WEIGHTS.FATIGUE * improvementRange;\n        const overall = Math.round(BASE_SCORE + weightedImprovement);\n        console.log('🔍 EyeHealthScorer: Base score calculation:', {\n            baseScore: BASE_SCORE,\n            improvementRange,\n            eyeStrainContribution: ((eyeStrainScore / 100) * (this.WEIGHTS.EAR + this.WEIGHTS.PERCLOS) * improvementRange).toFixed(1),\n            postureContribution: ((postureScore / 100) * this.WEIGHTS.POSTURE * improvementRange).toFixed(1),\n            fatigueContribution: ((fatigueScore / 100) * this.WEIGHTS.FATIGUE * improvementRange).toFixed(1),\n            totalImprovement: weightedImprovement.toFixed(1),\n            finalScore: overall\n        });\n        const trend = this.calculateTrend(metrics);\n        const recommendations = this.generateRecommendations({\n            eyeStrain: eyeStrainScore,\n            blinkHealth: blinkHealthScore,\n            postureHealth: postureScore,\n            fatigueLevel: fatigueScore\n        });\n        return {\n            overall: Math.max(BASE_SCORE, Math.min(100, overall)),\n            components: {\n                eyeStrain: eyeStrainScore,\n                blinkHealth: blinkHealthScore,\n                postureHealth: postureScore,\n                fatigueLevel: fatigueScore\n            },\n            trend,\n            recommendations\n        };\n    }\n    static calculateAverages(metrics) {\n        const sum = metrics.reduce((acc, m) => ({\n            earValue: acc.earValue + m.earValue,\n            perclosValue: acc.perclosValue + m.perclosValue,\n            blinkRate: acc.blinkRate + m.blinkRate,\n            fatigueIndex: acc.fatigueIndex + m.fatigueIndex\n        }), { earValue: 0, perclosValue: 0, blinkRate: 0, fatigueIndex: 0 });\n        const count = metrics.length;\n        return {\n            earValue: sum.earValue / count,\n            perclosValue: sum.perclosValue / count,\n            blinkRate: sum.blinkRate / count,\n            fatigueIndex: sum.fatigueIndex / count\n        };\n    }\n    static calculateEyeStrainScore(earValue, perclosValue) {\n        const earScore = this.scoreByThreshold(earValue, this.THRESHOLDS.EAR, true);\n        const perclosScore = this.scoreByThreshold(perclosValue, this.THRESHOLDS.PERCLOS, false);\n        return Math.round((earScore + perclosScore) / 2);\n    }\n    static calculateBlinkHealthScore(blinkRate) {\n        const thresholds = this.THRESHOLDS.BLINK_RATE;\n        // Optimal range is 15-20 blinks per minute\n        const optimal = (thresholds.EXCELLENT.min + thresholds.EXCELLENT.max) / 2; // 17.5\n        if (blinkRate >= thresholds.EXCELLENT.min && blinkRate <= thresholds.EXCELLENT.max) {\n            // Perfect range: 95-100\n            const deviation = Math.abs(blinkRate - optimal) / (thresholds.EXCELLENT.max - optimal);\n            return Math.round(100 - (deviation * 5));\n        }\n        else if (blinkRate >= thresholds.GOOD.min && blinkRate <= thresholds.GOOD.max) {\n            // Good range: 70-95\n            const distance = blinkRate < thresholds.EXCELLENT.min\n                ? (thresholds.EXCELLENT.min - blinkRate) / (thresholds.EXCELLENT.min - thresholds.GOOD.min)\n                : (blinkRate - thresholds.EXCELLENT.max) / (thresholds.GOOD.max - thresholds.EXCELLENT.max);\n            return Math.round(95 - (distance * 25));\n        }\n        else if (blinkRate >= thresholds.FAIR.min && blinkRate <= thresholds.FAIR.max) {\n            // Fair range: 40-70\n            const distance = blinkRate < thresholds.GOOD.min\n                ? (thresholds.GOOD.min - blinkRate) / (thresholds.GOOD.min - thresholds.FAIR.min)\n                : (blinkRate - thresholds.GOOD.max) / (thresholds.FAIR.max - thresholds.GOOD.max);\n            return Math.round(70 - (distance * 30));\n        }\n        else {\n            // Poor range: 0-40\n            const maxDistance = Math.max(Math.abs(blinkRate - thresholds.FAIR.min), Math.abs(blinkRate - thresholds.FAIR.max));\n            const normalizedDistance = Math.min(maxDistance / 20, 1); // Cap at reasonable distance\n            return Math.round(40 - (normalizedDistance * 40));\n        }\n    }\n    static calculatePostureScore(posture) {\n        // Add some randomization within ranges to create more dynamic scoring\n        const randomOffset = () => Math.floor(Math.random() * 6) - 3; // -3 to +3\n        switch (posture) {\n            case 'excellent': return Math.min(100, Math.max(92, 97 + randomOffset()));\n            case 'good': return Math.min(91, Math.max(75, 83 + randomOffset()));\n            case 'fair': return Math.min(74, Math.max(55, 65 + randomOffset()));\n            case 'poor': return Math.min(54, Math.max(25, 40 + randomOffset()));\n            case 'very_poor': return Math.min(24, Math.max(0, 15 + randomOffset()));\n            default: return Math.min(60, Math.max(40, 50 + randomOffset()));\n        }\n    }\n    static scoreByThreshold(value, thresholds, higherIsBetter) {\n        if (higherIsBetter) {\n            if (value >= thresholds.EXCELLENT) {\n                // Excellent range: 90-100\n                const excess = Math.min((value - thresholds.EXCELLENT) / (thresholds.EXCELLENT * 0.2), 1);\n                return Math.round(90 + (excess * 10));\n            }\n            if (value >= thresholds.GOOD) {\n                // Good range: 70-90\n                const progress = (value - thresholds.GOOD) / (thresholds.EXCELLENT - thresholds.GOOD);\n                return Math.round(70 + (progress * 20));\n            }\n            if (value >= thresholds.FAIR) {\n                // Fair range: 40-70\n                const progress = (value - thresholds.FAIR) / (thresholds.GOOD - thresholds.FAIR);\n                return Math.round(40 + (progress * 30));\n            }\n            // Poor range: 0-40\n            const progress = Math.max(0, value / thresholds.FAIR);\n            return Math.round(progress * 40);\n        }\n        else {\n            if (value <= thresholds.EXCELLENT) {\n                // Excellent range: 90-100\n                const quality = Math.max(0, 1 - (value / thresholds.EXCELLENT));\n                return Math.round(90 + (quality * 10));\n            }\n            if (value <= thresholds.GOOD) {\n                // Good range: 70-90\n                const progress = 1 - ((value - thresholds.EXCELLENT) / (thresholds.GOOD - thresholds.EXCELLENT));\n                return Math.round(70 + (progress * 20));\n            }\n            if (value <= thresholds.FAIR) {\n                // Fair range: 40-70\n                const progress = 1 - ((value - thresholds.GOOD) / (thresholds.FAIR - thresholds.GOOD));\n                return Math.round(40 + (progress * 30));\n            }\n            // Poor range: 0-40\n            const degradation = Math.min((value - thresholds.FAIR) / (thresholds.FAIR * 2), 1);\n            return Math.round(40 - (degradation * 40));\n        }\n    }\n    static calculateTrend(metrics) {\n        if (metrics.length < 5)\n            return 'stable';\n        const recent = metrics.slice(-5);\n        const older = metrics.slice(-10, -5);\n        if (older.length === 0)\n            return 'stable';\n        const recentAvg = recent.reduce((sum, m) => sum + (1 - m.fatigueIndex), 0) / recent.length;\n        const olderAvg = older.reduce((sum, m) => sum + (1 - m.fatigueIndex), 0) / older.length;\n        const difference = recentAvg - olderAvg;\n        if (difference > 0.05)\n            return 'improving';\n        if (difference < -0.05)\n            return 'declining';\n        return 'stable';\n    }\n    static generateRecommendations(scores) {\n        const recommendations = [];\n        if (scores.eyeStrain < 60) {\n            recommendations.push('Take more frequent breaks to reduce eye strain');\n            recommendations.push('Adjust screen brightness and contrast');\n        }\n        if (scores.blinkHealth < 60) {\n            recommendations.push('Practice conscious blinking exercises');\n            recommendations.push('Use artificial tears if eyes feel dry');\n        }\n        if (scores.postureHealth < 60) {\n            recommendations.push('Improve your sitting posture');\n            recommendations.push('Adjust monitor height to eye level');\n        }\n        if (scores.fatigueLevel < 60) {\n            recommendations.push('Get adequate sleep (7-9 hours)');\n            recommendations.push('Take longer breaks between work sessions');\n        }\n        if (recommendations.length === 0) {\n            recommendations.push('Great job! Keep maintaining healthy eye habits');\n        }\n        return recommendations;\n    }\n}\nEyeHealthScorer.WEIGHTS = {\n    EAR: 0.30, // Eye Aspect Ratio (increased from 0.25)\n    PERCLOS: 0.35, // Percentage of Eye Closure (increased from 0.30)\n    BLINK_RATE: 0.00, // Blink frequency (disabled for real-time scoring)\n    POSTURE: 0.25, // Head posture (increased from 0.15)\n    FATIGUE: 0.10 // Overall fatigue index\n};\nEyeHealthScorer.THRESHOLDS = {\n    EAR: {\n        EXCELLENT: 0.25, // Adjusted for real-world values (normal ~0.3, lower threshold for better scoring)\n        GOOD: 0.20,\n        FAIR: 0.15,\n        POOR: 0.10\n    },\n    PERCLOS: {\n        EXCELLENT: 0.15, // Adjusted for real-world values (lower is better, more lenient)\n        GOOD: 0.25,\n        FAIR: 0.35,\n        POOR: 0.50\n    },\n    BLINK_RATE: {\n        EXCELLENT: { min: 15, max: 20 },\n        GOOD: { min: 12, max: 25 },\n        FAIR: { min: 8, max: 30 },\n        POOR: { min: 0, max: 50 }\n    }\n};\n/**\n * Daily KPI Calculator\n * Aggregates daily metrics and calculates key performance indicators\n */\nexport class DailyKPICalculator {\n    /**\n     * Calculate daily KPIs from metrics and break sessions\n     */\n    static calculateDailyKPIs(metrics, breakSessions, date = new Date()) {\n        const dayStart = new Date(date);\n        dayStart.setHours(0, 0, 0, 0);\n        const dayEnd = new Date(date);\n        dayEnd.setHours(23, 59, 59, 999);\n        // Filter data for the specific day\n        const dayMetrics = metrics.filter(m => {\n            const metricDate = new Date(m.timestamp);\n            return metricDate >= dayStart && metricDate <= dayEnd;\n        });\n        const dayBreaks = breakSessions.filter(b => {\n            const breakDate = new Date(b.startTime);\n            return breakDate >= dayStart && breakDate <= dayEnd;\n        });\n        // Calculate screen time (approximate from metrics frequency)\n        const screenTimeMinutes = dayMetrics.length > 0\n            ? Math.round((dayMetrics.length * 30) / 60) // Assuming 30-second intervals\n            : 0;\n        // Calculate break statistics\n        const totalBreaks = dayBreaks.length;\n        const completedBreaks = dayBreaks.filter(b => b.completed).length;\n        const totalBreakTime = dayBreaks.reduce((sum, b) => sum + (b.duration || 0), 0);\n        // Calculate average metrics\n        const avgMetrics = dayMetrics.length > 0 ? {\n            earValue: dayMetrics.reduce((sum, m) => sum + m.earValue, 0) / dayMetrics.length,\n            perclosValue: dayMetrics.reduce((sum, m) => sum + m.perclosValue, 0) / dayMetrics.length,\n            blinkRate: dayMetrics.reduce((sum, m) => sum + m.blinkRate, 0) / dayMetrics.length,\n            fatigueIndex: dayMetrics.reduce((sum, m) => sum + m.fatigueIndex, 0) / dayMetrics.length\n        } : null;\n        // Calculate eye health score\n        const eyeHealthScore = EyeHealthScorer.calculateScore(dayMetrics);\n        return {\n            date: date.toISOString().split('T')[0],\n            screenTime: screenTimeMinutes,\n            totalBreaks,\n            completedBreaks,\n            breakCompletionRate: totalBreaks > 0 ? (completedBreaks / totalBreaks) * 100 : 0,\n            totalBreakTime,\n            averageMetrics: avgMetrics,\n            eyeHealthScore: eyeHealthScore.overall,\n            recommendations: eyeHealthScore.recommendations,\n            alerts: this.generateAlerts(avgMetrics, totalBreaks, screenTimeMinutes)\n        };\n    }\n    static generateAlerts(avgMetrics, totalBreaks, screenTime) {\n        const alerts = [];\n        if (screenTime > 480) { // More than 8 hours\n            alerts.push('Excessive screen time detected');\n        }\n        if (totalBreaks < 3 && screenTime > 120) { // Less than 3 breaks in 2+ hours\n            alerts.push('Take more frequent breaks');\n        }\n        if (avgMetrics && avgMetrics.fatigueIndex > 0.7) {\n            alerts.push('High fatigue levels detected');\n        }\n        if (avgMetrics && avgMetrics.perclosValue > 0.3) {\n            alerts.push('Excessive eye closure detected');\n        }\n        return alerts;\n    }\n}\n/**\n * Weekly Summary Generator\n * Creates weekly summaries and trends\n */\nexport class WeeklySummaryGenerator {\n    /**\n     * Generate weekly summary data\n     */\n    static generateWeeklySummary(metrics, breakSessions, weekStart) {\n        const weekEnd = new Date(weekStart);\n        weekEnd.setDate(weekEnd.getDate() + 6);\n        weekEnd.setHours(23, 59, 59, 999);\n        // Generate daily KPIs for each day of the week\n        const dailyKPIs = [];\n        for (let i = 0; i < 7; i++) {\n            const currentDay = new Date(weekStart);\n            currentDay.setDate(currentDay.getDate() + i);\n            const dayKPIs = DailyKPICalculator.calculateDailyKPIs(metrics, breakSessions, currentDay);\n            dailyKPIs.push(dayKPIs);\n        }\n        // Calculate weekly aggregates\n        const totalScreenTime = dailyKPIs.reduce((sum, day) => sum + day.screenTime, 0);\n        const totalBreaks = dailyKPIs.reduce((sum, day) => sum + day.totalBreaks, 0);\n        const avgEyeHealthScore = dailyKPIs.reduce((sum, day) => sum + day.eyeHealthScore, 0) / 7;\n        // Calculate trends\n        const eyeHealthTrend = this.calculateWeeklyTrend(dailyKPIs.map(day => day.eyeHealthScore));\n        const screenTimeTrend = this.calculateWeeklyTrend(dailyKPIs.map(day => day.screenTime));\n        return {\n            weekStart: weekStart.toISOString().split('T')[0],\n            weekEnd: weekEnd.toISOString().split('T')[0],\n            dailyKPIs,\n            summary: {\n                totalScreenTime,\n                avgDailyScreenTime: Math.round(totalScreenTime / 7),\n                totalBreaks,\n                avgEyeHealthScore: Math.round(avgEyeHealthScore),\n                eyeHealthTrend,\n                screenTimeTrend\n            },\n            insights: this.generateWeeklyInsights(dailyKPIs)\n        };\n    }\n    static calculateWeeklyTrend(values) {\n        if (values.length < 2)\n            return 'stable';\n        const firstHalf = values.slice(0, Math.floor(values.length / 2));\n        const secondHalf = values.slice(Math.floor(values.length / 2));\n        const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\n        const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\n        const difference = secondAvg - firstAvg;\n        const threshold = firstAvg * 0.1; // 10% threshold\n        if (difference > threshold)\n            return 'improving';\n        if (difference < -threshold)\n            return 'declining';\n        return 'stable';\n    }\n    static generateWeeklyInsights(dailyKPIs) {\n        const insights = [];\n        // Find best and worst days\n        const bestDay = dailyKPIs.reduce((best, day) => day.eyeHealthScore > best.eyeHealthScore ? day : best);\n        const worstDay = dailyKPIs.reduce((worst, day) => day.eyeHealthScore < worst.eyeHealthScore ? day : worst);\n        insights.push(`Best eye health day: ${new Date(bestDay.date).toLocaleDateString('en-US', { weekday: 'long' })}`);\n        insights.push(`Most challenging day: ${new Date(worstDay.date).toLocaleDateString('en-US', { weekday: 'long' })}`);\n        // Screen time insights\n        const avgScreenTime = dailyKPIs.reduce((sum, day) => sum + day.screenTime, 0) / 7;\n        if (avgScreenTime > 360) { // More than 6 hours average\n            insights.push('Consider reducing daily screen time');\n        }\n        // Break consistency\n        const daysWithGoodBreaks = dailyKPIs.filter(day => day.breakCompletionRate > 70).length;\n        if (daysWithGoodBreaks < 5) {\n            insights.push('Try to maintain consistent break habits throughout the week');\n        }\n        return insights;\n    }\n}\n"],"names":[],"sourceRoot":""}