"use strict";(self.webpackChunkeyezen_chrome_extension=self.webpackChunkeyezen_chrome_extension||[]).push([[123],{123:(t,e,a)=>{a.d(e,{L_:()=>s});var r=a(235);class s{static async initialize(){try{if(!await this.getUserData()){const t={settings:r.a$,metrics:[],breaks:[],events:[],score:{current:50,daily:50,weekly:50,trend:"stable"},lastUpdated:Date.now()};await this.saveUserData(t)}}catch(t){throw console.error("Failed to initialize storage:",t),new Error("Storage initialization failed")}}static async getUserData(){try{return(await chrome.storage.local.get([this.STORAGE_KEYS.USER_DATA]))[this.STORAGE_KEYS.USER_DATA]||null}catch(t){return console.error("Failed to get user data:",t),null}}static async saveUserData(t){try{t.lastUpdated=Date.now(),await chrome.storage.local.set({[this.STORAGE_KEYS.USER_DATA]:t})}catch(t){throw console.error("Failed to save user data:",t),new Error("Failed to save user data")}}static async getSettings(){try{const t=await this.getUserData();return t?.settings||r.a$}catch(t){return console.error("Failed to get settings:",t),r.a$}}static async updateSettings(t){try{const e=await this.getUserData();e&&(e.settings={...e.settings,...t},await this.saveUserData(e))}catch(t){throw console.error("Failed to update settings:",t),new Error("Failed to update settings")}}static async addMetrics(t){try{const e=await this.getUserData();if(e){e.metrics.push(t);const a=e.settings.dataRetention,r=Date.now()-24*a*60*60*1e3;e.metrics=e.metrics.filter(t=>t.timestamp>r),await this.saveUserData(e)}}catch(t){throw console.error("Failed to add metrics:",t),new Error("Failed to add metrics")}}static async getMetrics(t,e){try{const a=await this.getUserData();if(!a)return[];let r=a.metrics;return t&&(r=r.filter(e=>e.timestamp>=t.getTime())),e&&(r=r.filter(t=>t.timestamp<=e.getTime())),r.sort((t,e)=>t.timestamp-e.timestamp)}catch(t){return console.error("Failed to get metrics:",t),[]}}static async addBreakSession(t){try{const e=await this.getUserData();if(e){e.breaks.push(t);const a=e.settings.dataRetention,r=Date.now()-24*a*60*60*1e3;e.breaks=e.breaks.filter(t=>t.startTime>r),await this.saveUserData(e)}}catch(t){throw console.error("Failed to add break session:",t),new Error("Failed to add break session")}}static async updateBreakSession(t,e){try{const a=await this.getUserData();if(a){const r=a.breaks.findIndex(e=>e.id===t);-1!==r&&(a.breaks[r]={...a.breaks[r],...e},await this.saveUserData(a))}}catch(t){throw console.error("Failed to update break session:",t),new Error("Failed to update break session")}}static async getBreakSessions(t,e){try{const a=await this.getUserData();if(!a)return[];let r=a.breaks;return t&&(r=r.filter(e=>e.startTime>=t.getTime())),e&&(r=r.filter(t=>t.startTime<=e.getTime())),r.sort((t,e)=>t.startTime-e.startTime)}catch(t){return console.error("Failed to get break sessions:",t),[]}}static async addEvent(t){try{const e=await this.getUserData();if(e){e.events.push(t);const a=e.settings.dataRetention,r=Date.now()-24*a*60*60*1e3;e.events=e.events.filter(t=>t.timestamp>r),await this.saveUserData(e)}}catch(t){throw console.error("Failed to add event:",t),new Error("Failed to add event")}}static async getStorageInfo(){try{return{used:await chrome.storage.local.getBytesInUse(),quota:chrome.storage.local.QUOTA_BYTES}}catch(t){return console.error("Failed to get storage info:",t),{used:0,quota:0}}}static async clearAllData(){try{await chrome.storage.local.clear(),await this.initialize()}catch(t){throw console.error("Failed to clear data:",t),new Error("Failed to clear data")}}static async exportData(){try{const t=await this.getUserData();if(!t)throw new Error("No data to export");return JSON.stringify(t,null,2)}catch(t){throw console.error("Failed to export data:",t),new Error("Failed to export data")}}static async importData(t){try{const e=JSON.parse(t);if(!e.settings||!e.metrics||!e.breaks)throw new Error("Invalid data format");await this.saveUserData(e)}catch(t){throw console.error("Failed to import data:",t),new Error("Failed to import data")}}}s.STORAGE_KEYS={USER_DATA:"eyezen_user_data",SETTINGS:"eyezen_settings",METRICS:"eyezen_metrics",BREAKS:"eyezen_breaks",EVENTS:"eyezen_events",LAST_SYNC:"eyezen_last_sync"};class i{static async initialize(){return new Promise((t,e)=>{const a=indexedDB.open(this.DB_NAME,this.DB_VERSION);a.onerror=()=>{e(new Error("Failed to open IndexedDB"))},a.onsuccess=()=>{this.db=a.result,t()},a.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains(this.STORES.METRICS)){const t=e.createObjectStore(this.STORES.METRICS,{keyPath:"timestamp"});t.createIndex("date","date",{unique:!1}),t.createIndex("fatigueIndex","fatigueIndex",{unique:!1})}if(!e.objectStoreNames.contains(this.STORES.BREAKS)){const t=e.createObjectStore(this.STORES.BREAKS,{keyPath:"id"});t.createIndex("startTime","startTime",{unique:!1}),t.createIndex("type","type",{unique:!1})}if(!e.objectStoreNames.contains(this.STORES.EVENTS)){const t=e.createObjectStore(this.STORES.EVENTS,{keyPath:"id"});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("type","type",{unique:!1})}e.objectStoreNames.contains(this.STORES.CACHE)||e.createObjectStore(this.STORES.CACHE,{keyPath:"key"})}})}static async storeMetrics(t){return this.db||await this.initialize(),new Promise((e,a)=>{const r=this.db.transaction([this.STORES.METRICS],"readwrite"),s=r.objectStore(this.STORES.METRICS);t.forEach(t=>{const e={...t,date:new Date(t.timestamp).toISOString().split("T")[0]};s.put(e)}),r.oncomplete=()=>e(),r.onerror=()=>a(new Error("Failed to store metrics"))})}static async queryMetrics(t){return this.db||await this.initialize(),new Promise((e,a)=>{const r=this.db.transaction([this.STORES.METRICS],"readonly"),s=r.objectStore(this.STORES.METRICS),i=[];let o;if(t.startDate||t.endDate){const e=s.index("timestamp"),a=IDBKeyRange.bound(t.startDate?.getTime()||0,t.endDate?.getTime()||Date.now());o=e.openCursor(a)}else o=s.openCursor();o.onsuccess=e=>{const a=e.target.result;if(a){const e=a.value;(!t.fatigueThreshold||e.fatigueIndex>=t.fatigueThreshold)&&i.push(e),(!t.limit||i.length<t.limit)&&a.continue()}},r.oncomplete=()=>e(i),r.onerror=()=>a(new Error("Failed to query metrics"))})}static async getDailyAggregates(t){const e=new Date(t);e.setHours(0,0,0,0);const a=new Date(t);a.setHours(23,59,59,999);const r=await this.queryMetrics({startDate:e,endDate:a});if(0===r.length)return{avgFatigue:0,avgBlinkRate:0,totalReadings:0,peakFatigue:0};const s=r.reduce((t,e)=>t+e.fatigueIndex,0),i=r.reduce((t,e)=>t+e.blinkRate,0),o=Math.max(...r.map(t=>t.fatigueIndex));return{avgFatigue:s/r.length,avgBlinkRate:i/r.length,totalReadings:r.length,peakFatigue:o}}static async setCache(t,e,a=36e5){return this.db||await this.initialize(),new Promise((r,s)=>{const i=this.db.transaction([this.STORES.CACHE],"readwrite").objectStore(this.STORES.CACHE),o={key:t,data:e,expires:Date.now()+a},n=i.put(o);n.onsuccess=()=>r(),n.onerror=()=>s(new Error("Failed to set cache"))})}static async getCache(t){return this.db||await this.initialize(),new Promise((e,a)=>{const r=this.db.transaction([this.STORES.CACHE],"readonly").objectStore(this.STORES.CACHE).get(t);r.onsuccess=()=>{const t=r.result;t&&t.expires>Date.now()?e(t.data):e(null)},r.onerror=()=>a(new Error("Failed to get cache"))})}static async clearExpiredCache(){return this.db||await this.initialize(),new Promise((t,e)=>{const a=this.db.transaction([this.STORES.CACHE],"readwrite");a.objectStore(this.STORES.CACHE).openCursor().onsuccess=t=>{const e=t.target.result;e&&(e.value.expires<=Date.now()&&e.delete(),e.continue())},a.oncomplete=()=>t(),a.onerror=()=>e(new Error("Failed to clear expired cache"))})}static async getDatabaseSize(){return this.db||await this.initialize(),new Promise(t=>{let e=0;const a=Array.from(this.db.objectStoreNames);let r=0;a.forEach(s=>{const i=this.db.transaction([s],"readonly").objectStore(s).count();i.onsuccess=()=>{e+=i.result,r++,r===a.length&&t(e)}})})}static async clearDatabase(){return this.db||await this.initialize(),new Promise((t,e)=>{const a=Array.from(this.db.objectStoreNames),r=this.db.transaction(a,"readwrite");a.forEach(t=>{r.objectStore(t).clear()}),r.oncomplete=()=>t(),r.onerror=()=>e(new Error("Failed to clear database"))})}}i.DB_NAME="EyeZenDB",i.DB_VERSION=1,i.STORES={METRICS:"metrics",BREAKS:"breaks",EVENTS:"events",CACHE:"cache"},i.db=null;class o{static async runMigrations(){try{const t=await this.getCurrentMigrationVersion();t<this.CURRENT_VERSION&&(await this.migrate(t,this.CURRENT_VERSION),await this.setMigrationVersion(this.CURRENT_VERSION))}catch(t){throw console.error("Migration failed:",t),new Error("Data migration failed")}}static async getCurrentMigrationVersion(){try{return(await chrome.storage.local.get([this.MIGRATION_KEY]))[this.MIGRATION_KEY]||0}catch(t){return 0}}static async setMigrationVersion(t){await chrome.storage.local.set({[this.MIGRATION_KEY]:t})}static async migrate(t,e){console.log(`Migrating data from version ${t} to ${e}`),await s.initialize(),await i.initialize()}}o.MIGRATION_KEY="eyezen_migration_version",o.CURRENT_VERSION=1}}]);