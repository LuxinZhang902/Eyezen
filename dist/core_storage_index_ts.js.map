{"version":3,"file":"core_storage_index_ts.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACjmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://eyezen-chrome-extension/./core/storage/index.ts","webpack://eyezen-chrome-extension/./types/index.ts"],"sourcesContent":["/**\n * Storage Module\n * Handles data persistence using chrome.storage.local and IndexedDB\n */\nimport { DEFAULT_SETTINGS } from '../../types/index';\n/**\n * Chrome Storage Service\n * Handles chrome.storage.local operations\n */\nexport class ChromeStorageService {\n    /**\n     * Initialize storage with default values\n     */\n    static async initialize() {\n        try {\n            if (!this.isChromeApiAvailable()) {\n                console.warn('Chrome API not available, skipping initialization');\n                return;\n            }\n            const existingData = await this.getUserData();\n            if (!existingData) {\n                const defaultUserData = {\n                    settings: DEFAULT_SETTINGS,\n                    metrics: [],\n                    breaks: [],\n                    events: [],\n                    score: {\n                        current: 50,\n                        daily: 50,\n                        weekly: 50,\n                        trend: 'stable'\n                    },\n                    lastUpdated: Date.now()\n                };\n                await this.saveUserData(defaultUserData);\n            }\n        }\n        catch (error) {\n            console.error('Failed to initialize storage:', error);\n            throw new Error('Storage initialization failed');\n        }\n    }\n    /**\n     * Check if Chrome API is available\n     */\n    static isChromeApiAvailable() {\n        return typeof chrome !== 'undefined' &&\n            chrome.storage !== undefined &&\n            chrome.storage.local !== undefined;\n    }\n    /**\n     * Get complete user data\n     */\n    static async getUserData() {\n        try {\n            if (!this.isChromeApiAvailable()) {\n                console.warn('Chrome API not available, returning mock data');\n                return null;\n            }\n            const result = await chrome.storage.local.get([this.STORAGE_KEYS.USER_DATA]);\n            return result[this.STORAGE_KEYS.USER_DATA] || null;\n        }\n        catch (error) {\n            console.error('Failed to get user data:', error);\n            return null;\n        }\n    }\n    /**\n     * Save complete user data\n     */\n    static async saveUserData(userData) {\n        try {\n            if (!this.isChromeApiAvailable()) {\n                console.warn('Chrome API not available, skipping save');\n                return;\n            }\n            userData.lastUpdated = Date.now();\n            await chrome.storage.local.set({\n                [this.STORAGE_KEYS.USER_DATA]: userData\n            });\n        }\n        catch (error) {\n            console.error('Failed to save user data:', error);\n            throw new Error('Failed to save user data');\n        }\n    }\n    /**\n     * Get user settings\n     */\n    static async getSettings() {\n        try {\n            const userData = await this.getUserData();\n            return userData?.settings || DEFAULT_SETTINGS;\n        }\n        catch (error) {\n            console.error('Failed to get settings:', error);\n            return DEFAULT_SETTINGS;\n        }\n    }\n    /**\n     * Update user settings\n     */\n    static async updateSettings(newSettings) {\n        try {\n            const userData = await this.getUserData();\n            if (userData) {\n                userData.settings = { ...userData.settings, ...newSettings };\n                await this.saveUserData(userData);\n            }\n        }\n        catch (error) {\n            console.error('Failed to update settings:', error);\n            throw new Error('Failed to update settings');\n        }\n    }\n    /**\n     * Add eye metrics\n     */\n    static async addMetrics(metrics) {\n        try {\n            const userData = await this.getUserData();\n            if (userData) {\n                userData.metrics.push(metrics);\n                // Keep only recent metrics based on retention settings\n                const retentionDays = userData.settings.dataRetention;\n                const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n                userData.metrics = userData.metrics.filter(m => m.timestamp > cutoffTime);\n                await this.saveUserData(userData);\n            }\n        }\n        catch (error) {\n            console.error('Failed to add metrics:', error);\n            throw new Error('Failed to add metrics');\n        }\n    }\n    /**\n     * Get metrics within date range\n     */\n    static async getMetrics(startDate, endDate) {\n        try {\n            const userData = await this.getUserData();\n            if (!userData)\n                return [];\n            let metrics = userData.metrics;\n            if (startDate) {\n                metrics = metrics.filter(m => m.timestamp >= startDate.getTime());\n            }\n            if (endDate) {\n                metrics = metrics.filter(m => m.timestamp <= endDate.getTime());\n            }\n            return metrics.sort((a, b) => a.timestamp - b.timestamp);\n        }\n        catch (error) {\n            console.error('Failed to get metrics:', error);\n            return [];\n        }\n    }\n    /**\n     * Add break session\n     */\n    static async addBreakSession(breakSession) {\n        try {\n            const userData = await this.getUserData();\n            if (userData) {\n                userData.breaks.push(breakSession);\n                // Keep only recent breaks\n                const retentionDays = userData.settings.dataRetention;\n                const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n                userData.breaks = userData.breaks.filter(b => b.startTime > cutoffTime);\n                await this.saveUserData(userData);\n            }\n        }\n        catch (error) {\n            console.error('Failed to add break session:', error);\n            throw new Error('Failed to add break session');\n        }\n    }\n    /**\n     * Update break session\n     */\n    static async updateBreakSession(sessionId, updates) {\n        try {\n            const userData = await this.getUserData();\n            if (userData) {\n                const sessionIndex = userData.breaks.findIndex(b => b.id === sessionId);\n                if (sessionIndex !== -1) {\n                    userData.breaks[sessionIndex] = { ...userData.breaks[sessionIndex], ...updates };\n                    await this.saveUserData(userData);\n                }\n            }\n        }\n        catch (error) {\n            console.error('Failed to update break session:', error);\n            throw new Error('Failed to update break session');\n        }\n    }\n    /**\n     * Get break sessions within date range\n     */\n    static async getBreakSessions(startDate, endDate) {\n        try {\n            const userData = await this.getUserData();\n            if (!userData)\n                return [];\n            let breaks = userData.breaks;\n            if (startDate) {\n                breaks = breaks.filter(b => b.startTime >= startDate.getTime());\n            }\n            if (endDate) {\n                breaks = breaks.filter(b => b.startTime <= endDate.getTime());\n            }\n            return breaks.sort((a, b) => a.startTime - b.startTime);\n        }\n        catch (error) {\n            console.error('Failed to get break sessions:', error);\n            return [];\n        }\n    }\n    /**\n     * Add user event\n     */\n    static async addEvent(event) {\n        try {\n            const userData = await this.getUserData();\n            if (userData) {\n                userData.events.push(event);\n                // Keep only recent events\n                const retentionDays = userData.settings.dataRetention;\n                const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n                userData.events = userData.events.filter(e => e.timestamp > cutoffTime);\n                await this.saveUserData(userData);\n            }\n        }\n        catch (error) {\n            console.error('Failed to add event:', error);\n            throw new Error('Failed to add event');\n        }\n    }\n    /**\n     * Get storage usage information\n     */\n    static async getStorageInfo() {\n        try {\n            const usage = await chrome.storage.local.getBytesInUse();\n            return {\n                used: usage,\n                quota: chrome.storage.local.QUOTA_BYTES\n            };\n        }\n        catch (error) {\n            console.error('Failed to get storage info:', error);\n            return { used: 0, quota: 0 };\n        }\n    }\n    /**\n     * Clear all data (privacy feature)\n     */\n    static async clearAllData() {\n        try {\n            await chrome.storage.local.clear();\n            await this.initialize(); // Reinitialize with defaults\n        }\n        catch (error) {\n            console.error('Failed to clear data:', error);\n            throw new Error('Failed to clear data');\n        }\n    }\n    /**\n     * Export data for backup\n     */\n    static async exportData() {\n        try {\n            const userData = await this.getUserData();\n            if (!userData) {\n                throw new Error('No data to export');\n            }\n            return JSON.stringify(userData, null, 2);\n        }\n        catch (error) {\n            console.error('Failed to export data:', error);\n            throw new Error('Failed to export data');\n        }\n    }\n    /**\n     * Import data from backup\n     */\n    static async importData(jsonData) {\n        try {\n            const userData = JSON.parse(jsonData);\n            // Validate data structure\n            if (!userData.settings || !userData.metrics || !userData.breaks) {\n                throw new Error('Invalid data format');\n            }\n            await this.saveUserData(userData);\n        }\n        catch (error) {\n            console.error('Failed to import data:', error);\n            throw new Error('Failed to import data');\n        }\n    }\n}\nChromeStorageService.STORAGE_KEYS = {\n    USER_DATA: 'eyezen_user_data',\n    SETTINGS: 'eyezen_settings',\n    METRICS: 'eyezen_metrics',\n    BREAKS: 'eyezen_breaks',\n    EVENTS: 'eyezen_events',\n    LAST_SYNC: 'eyezen_last_sync'\n};\n/**\n * IndexedDB Service\n * Handles large data storage and complex queries\n */\nexport class IndexedDBService {\n    /**\n     * Initialize IndexedDB\n     */\n    static async initialize() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n            request.onerror = () => {\n                reject(new Error('Failed to open IndexedDB'));\n            };\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Create metrics store\n                if (!db.objectStoreNames.contains(this.STORES.METRICS)) {\n                    const metricsStore = db.createObjectStore(this.STORES.METRICS, {\n                        keyPath: 'timestamp'\n                    });\n                    metricsStore.createIndex('date', 'date', { unique: false });\n                    metricsStore.createIndex('fatigueIndex', 'fatigueIndex', { unique: false });\n                }\n                // Create breaks store\n                if (!db.objectStoreNames.contains(this.STORES.BREAKS)) {\n                    const breaksStore = db.createObjectStore(this.STORES.BREAKS, {\n                        keyPath: 'id'\n                    });\n                    breaksStore.createIndex('startTime', 'startTime', { unique: false });\n                    breaksStore.createIndex('type', 'type', { unique: false });\n                }\n                // Create events store\n                if (!db.objectStoreNames.contains(this.STORES.EVENTS)) {\n                    const eventsStore = db.createObjectStore(this.STORES.EVENTS, {\n                        keyPath: 'id'\n                    });\n                    eventsStore.createIndex('timestamp', 'timestamp', { unique: false });\n                    eventsStore.createIndex('type', 'type', { unique: false });\n                }\n                // Create cache store\n                if (!db.objectStoreNames.contains(this.STORES.CACHE)) {\n                    db.createObjectStore(this.STORES.CACHE, {\n                        keyPath: 'key'\n                    });\n                }\n            };\n        });\n    }\n    /**\n     * Store metrics in IndexedDB\n     */\n    static async storeMetrics(metrics) {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([this.STORES.METRICS], 'readwrite');\n            const store = transaction.objectStore(this.STORES.METRICS);\n            metrics.forEach(metric => {\n                const enrichedMetric = {\n                    ...metric,\n                    date: new Date(metric.timestamp).toISOString().split('T')[0]\n                };\n                store.put(enrichedMetric);\n            });\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(new Error('Failed to store metrics'));\n        });\n    }\n    /**\n     * Query metrics with advanced filtering\n     */\n    static async queryMetrics(options) {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([this.STORES.METRICS], 'readonly');\n            const store = transaction.objectStore(this.STORES.METRICS);\n            const results = [];\n            let request;\n            if (options.startDate || options.endDate) {\n                const index = store.index('timestamp');\n                const range = IDBKeyRange.bound(options.startDate?.getTime() || 0, options.endDate?.getTime() || Date.now());\n                request = index.openCursor(range);\n            }\n            else {\n                request = store.openCursor();\n            }\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    const metric = cursor.value;\n                    // Apply fatigue threshold filter\n                    if (!options.fatigueThreshold || metric.fatigueIndex >= options.fatigueThreshold) {\n                        results.push(metric);\n                    }\n                    // Apply limit\n                    if (!options.limit || results.length < options.limit) {\n                        cursor.continue();\n                    }\n                }\n            };\n            transaction.oncomplete = () => resolve(results);\n            transaction.onerror = () => reject(new Error('Failed to query metrics'));\n        });\n    }\n    /**\n     * Get daily aggregated metrics\n     */\n    static async getDailyAggregates(date) {\n        const startOfDay = new Date(date);\n        startOfDay.setHours(0, 0, 0, 0);\n        const endOfDay = new Date(date);\n        endOfDay.setHours(23, 59, 59, 999);\n        const metrics = await this.queryMetrics({\n            startDate: startOfDay,\n            endDate: endOfDay\n        });\n        if (metrics.length === 0) {\n            return {\n                avgFatigue: 0,\n                avgBlinkRate: 0,\n                totalReadings: 0,\n                peakFatigue: 0\n            };\n        }\n        const totalFatigue = metrics.reduce((sum, m) => sum + m.fatigueIndex, 0);\n        const totalBlinkRate = metrics.reduce((sum, m) => sum + m.blinkRate, 0);\n        const peakFatigue = Math.max(...metrics.map(m => m.fatigueIndex));\n        return {\n            avgFatigue: totalFatigue / metrics.length,\n            avgBlinkRate: totalBlinkRate / metrics.length,\n            totalReadings: metrics.length,\n            peakFatigue\n        };\n    }\n    /**\n     * Cache data with expiration\n     */\n    static async setCache(key, data, expirationMs = 3600000) {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([this.STORES.CACHE], 'readwrite');\n            const store = transaction.objectStore(this.STORES.CACHE);\n            const cacheItem = {\n                key,\n                data,\n                expires: Date.now() + expirationMs\n            };\n            const request = store.put(cacheItem);\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(new Error('Failed to set cache'));\n        });\n    }\n    /**\n     * Get cached data\n     */\n    static async getCache(key) {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([this.STORES.CACHE], 'readonly');\n            const store = transaction.objectStore(this.STORES.CACHE);\n            const request = store.get(key);\n            request.onsuccess = () => {\n                const result = request.result;\n                if (result && result.expires > Date.now()) {\n                    resolve(result.data);\n                }\n                else {\n                    resolve(null);\n                }\n            };\n            request.onerror = () => reject(new Error('Failed to get cache'));\n        });\n    }\n    /**\n     * Clear expired cache entries\n     */\n    static async clearExpiredCache() {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([this.STORES.CACHE], 'readwrite');\n            const store = transaction.objectStore(this.STORES.CACHE);\n            const request = store.openCursor();\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    const item = cursor.value;\n                    if (item.expires <= Date.now()) {\n                        cursor.delete();\n                    }\n                    cursor.continue();\n                }\n            };\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(new Error('Failed to clear expired cache'));\n        });\n    }\n    /**\n     * Get database size\n     */\n    static async getDatabaseSize() {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve) => {\n            let totalSize = 0;\n            const storeNames = Array.from(this.db.objectStoreNames);\n            let completed = 0;\n            storeNames.forEach(storeName => {\n                const transaction = this.db.transaction([storeName], 'readonly');\n                const store = transaction.objectStore(storeName);\n                const request = store.count();\n                request.onsuccess = () => {\n                    totalSize += request.result;\n                    completed++;\n                    if (completed === storeNames.length) {\n                        resolve(totalSize);\n                    }\n                };\n            });\n        });\n    }\n    /**\n     * Clear all IndexedDB data\n     */\n    static async clearDatabase() {\n        if (!this.db)\n            await this.initialize();\n        return new Promise((resolve, reject) => {\n            const storeNames = Array.from(this.db.objectStoreNames);\n            const transaction = this.db.transaction(storeNames, 'readwrite');\n            storeNames.forEach(storeName => {\n                const store = transaction.objectStore(storeName);\n                store.clear();\n            });\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(new Error('Failed to clear database'));\n        });\n    }\n}\nIndexedDBService.DB_NAME = 'EyeZenDB';\nIndexedDBService.DB_VERSION = 1;\nIndexedDBService.STORES = {\n    METRICS: 'metrics',\n    BREAKS: 'breaks',\n    EVENTS: 'events',\n    CACHE: 'cache'\n};\nIndexedDBService.db = null;\n/**\n * Data Migration Service\n * Handles data migration between versions\n */\nexport class DataMigrationService {\n    /**\n     * Run necessary migrations\n     */\n    static async runMigrations() {\n        try {\n            const currentVersion = await this.getCurrentMigrationVersion();\n            if (currentVersion < this.CURRENT_VERSION) {\n                await this.migrate(currentVersion, this.CURRENT_VERSION);\n                await this.setMigrationVersion(this.CURRENT_VERSION);\n            }\n        }\n        catch (error) {\n            console.error('Migration failed:', error);\n            throw new Error('Data migration failed');\n        }\n    }\n    static async getCurrentMigrationVersion() {\n        try {\n            const result = await chrome.storage.local.get([this.MIGRATION_KEY]);\n            return result[this.MIGRATION_KEY] || 0;\n        }\n        catch (error) {\n            return 0;\n        }\n    }\n    static async setMigrationVersion(version) {\n        await chrome.storage.local.set({\n            [this.MIGRATION_KEY]: version\n        });\n    }\n    static async migrate(fromVersion, toVersion) {\n        console.log(`Migrating data from version ${fromVersion} to ${toVersion}`);\n        // Add migration logic here as needed\n        // For now, we'll just ensure the storage is properly initialized\n        await ChromeStorageService.initialize();\n        await IndexedDBService.initialize();\n    }\n}\nDataMigrationService.MIGRATION_KEY = 'eyezen_migration_version';\nDataMigrationService.CURRENT_VERSION = 1;\n","// Core types for EyeZen Chrome Extension\nexport var PostureStatus;\n(function (PostureStatus) {\n    PostureStatus[\"GOOD\"] = \"good\";\n    PostureStatus[\"FORWARD\"] = \"forward\";\n    PostureStatus[\"TILTED\"] = \"tilted\";\n    PostureStatus[\"TOO_CLOSE\"] = \"too_close\";\n    PostureStatus[\"TOO_FAR\"] = \"too_far\";\n})(PostureStatus || (PostureStatus = {}));\n// User status and scoring\nexport var UserStatus;\n(function (UserStatus) {\n    UserStatus[\"GOOD\"] = \"good\";\n    UserStatus[\"TIRED\"] = \"tired\";\n    UserStatus[\"CRITICAL\"] = \"critical\";\n})(UserStatus || (UserStatus = {}));\nexport var BreakType;\n(function (BreakType) {\n    BreakType[\"MICRO\"] = \"micro\";\n    BreakType[\"SHORT\"] = \"short\";\n    BreakType[\"LONG\"] = \"long\"; // 15 minutes\n})(BreakType || (BreakType = {}));\nexport var MassagePointType;\n(function (MassagePointType) {\n    MassagePointType[\"ZAN_ZHU\"] = \"zan_zhu\";\n    MassagePointType[\"SI_BAI\"] = \"si_bai\";\n    MassagePointType[\"JING_MING\"] = \"jing_ming\"; // 睛明\n})(MassagePointType || (MassagePointType = {}));\n// Error types\nexport class EyeZenError extends Error {\n    constructor(message, code, severity = 'medium') {\n        super(message);\n        this.code = code;\n        this.severity = severity;\n        this.name = 'EyeZenError';\n    }\n}\n// Constants\nexport const DEFAULT_SETTINGS = {\n    cameraEnabled: true,\n    detectionSensitivity: 'medium',\n    fatigueThreshold: 70,\n    reminderEnabled: true,\n    reminderInterval: 20,\n    breakDuration: 20,\n    dataRetention: 30,\n    metricsOnly: false,\n    language: 'en',\n    theme: 'auto',\n    notifications: true,\n    sounds: true,\n    dailyBreakGoal: 8,\n    eyeScoreGoal: 80\n};\nexport const MASSAGE_POINTS = {\n    [MassagePointType.ZAN_ZHU]: {\n        name: 'Zan Zhu',\n        chineseName: '攒竹',\n        position: { x: 0.3, y: 0.25 },\n        description: 'Inner end of eyebrow',\n        benefits: ['Relieves eye strain', 'Reduces headaches', 'Improves focus'],\n        duration: 30\n    },\n    [MassagePointType.SI_BAI]: {\n        name: 'Si Bai',\n        chineseName: '四白',\n        position: { x: 0.35, y: 0.45 },\n        description: 'Below the center of the eye',\n        benefits: ['Brightens eyes', 'Reduces dark circles', 'Improves circulation'],\n        duration: 30\n    },\n    [MassagePointType.JING_MING]: {\n        name: 'Jing Ming',\n        chineseName: '睛明',\n        position: { x: 0.25, y: 0.35 },\n        description: 'Inner corner of the eye',\n        benefits: ['Clears vision', 'Reduces eye fatigue', 'Calms the mind'],\n        duration: 30\n    }\n};\n// Export all types\n// Note: Chrome types will be available via @types/chrome package\n// Additional type exports can be added here as needed\n"],"names":[],"sourceRoot":""}