(()=>{"use strict";var e,t,s,r,a={d:(e,t)=>{for(var s in t)a.o(t,s)&&!a.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},i={};a.r(i),a.d(i,{default:()=>h}),function(e){e.GOOD="good",e.FORWARD="forward",e.TILTED="tilted",e.TOO_CLOSE="too_close",e.TOO_FAR="too_far"}(e||(e={})),function(e){e.GOOD="good",e.TIRED="tired",e.CRITICAL="critical"}(t||(t={})),function(e){e.MICRO="micro",e.SHORT="short",e.LONG="long"}(s||(s={})),function(e){e.ZAN_ZHU="zan_zhu",e.SI_BAI="si_bai",e.JING_MING="jing_ming"}(r||(r={})),Error,r.ZAN_ZHU,r.SI_BAI,r.JING_MING;class o{static calculateEAR(e){if(e.length<6)throw new Error("Insufficient eye landmarks for EAR calculation");const[t,s,r,a,i,o]=e;return(this.euclideanDistance(s,o)+this.euclideanDistance(r,i))/(2*this.euclideanDistance(t,a))}static calculateAverageEAR(e,t){return(this.calculateEAR(e)+this.calculateEAR(t))/2}static euclideanDistance(e,t){const s=e.x-t.x,r=e.y-t.y,a=e.z-t.z;return Math.sqrt(s*s+r*r+a*a)}}class n{constructor(e=30,t=.2){this.earHistory=[],this.windowSize=e,this.closureThreshold=t}addEARValue(e){return this.earHistory.push(e),this.earHistory.length>this.windowSize&&this.earHistory.shift(),this.calculatePERCLOS()}calculatePERCLOS(){return 0===this.earHistory.length?0:this.earHistory.filter(e=>e<this.closureThreshold).length/this.earHistory.length*100}reset(){this.earHistory=[]}getWindowSize(){return this.earHistory.length}}class c{constructor(e=.2,t=100,s=400){this.earHistory=[],this.blinkCount=0,this.lastBlinkTime=0,this.blinkThreshold=e,this.minBlinkDuration=t,this.maxBlinkDuration=s}processEAR(e,t){return this.earHistory.push(e),this.earHistory.length>10&&this.earHistory.shift(),!!this.detectBlinkPattern(t)&&(this.blinkCount++,this.lastBlinkTime=t,!0)}getBlinkRate(e=6e4){const t=Date.now(),s=Math.min(e,t-this.lastBlinkTime);return 0===s?0:this.blinkCount/s*6e4}reset(){this.earHistory=[],this.blinkCount=0,this.lastBlinkTime=Date.now()}detectBlinkPattern(e){if(this.earHistory.length<3)return!1;const t=this.earHistory.slice(-3),[s,r,a]=t;return s>this.blinkThreshold&&r<=this.blinkThreshold&&(void 0===a||a>this.blinkThreshold)}}class l{static estimatePose(e){const t=e[1],s=e[33],r=e[263],a=e[61],i=e[291],o=Math.abs(s.x-r.x),n=(s.x+r.x)/2,c=(t.x-n)/o,l=(s.y+r.y)/2,h=(a.y+i.y)/2,d=Math.abs(h-l),u=(t.y-l)/d,g=(r.y-s.y)/(r.x-s.x),p=Math.atan(g);return{pitch:180*u/Math.PI,yaw:180*c/Math.PI,roll:180*p/Math.PI}}static classifyPosture(t){const{pitch:s,yaw:r,roll:a}=t;return Math.abs(s)>15?s>0?e.FORWARD:e.GOOD:Math.abs(r)>20||Math.abs(a)>15?e.TILTED:e.GOOD}}const h=new class{constructor(){this.faceLandmarker=null,this.isProcessing=!1,this.lastFrameTime=0,this.frameCount=0,this.targetFPS=15,this.frameInterval=1e3/this.targetFPS,this.perclosCalculator=new n(30,.2),this.blinkDetector=new c(.2,100,400),self.addEventListener("message",this.handleMessage.bind(this))}async handleMessage(e){const{type:t,data:s}=e.data;console.log(`ðŸ“¨ CV Worker: Received ${t} message`,s?"with data":"without data"),"process"!==t&&console.log("ðŸ”§ CV Worker received message:",t,s?"with data":"no data");try{switch(t){case"init":await this.initialize(s);break;case"start":console.log("ðŸš€ CV Worker: Starting processing"),this.startProcessing();break;case"process":s?(console.log("ðŸŽ¯ CV Worker: Processing frame message received"),await this.processFrame(s)):console.warn("âš ï¸ CV Worker: Process message received without data");break;case"stop":this.stopProcessing();break;case"cleanup":await this.cleanup();break;default:this.postError(`Unknown message type: ${t}`)}}catch(e){const s=e instanceof Error?e.message:String(e);this.postError(`Error handling ${t}: ${s}`)}}async initialize(e){try{console.log("ðŸš€ CV Worker: Initializing MediaPipe Face Landmarker..."),await this.loadMediaPipeScripts(),this.faceLandmarker={initialized:!0},console.log("âœ… CV Worker: MediaPipe Face Landmarker initialized successfully"),this.postMessage({type:"ready",data:{message:"CV Worker initialized successfully"}})}catch(e){const t=e instanceof Error?e.message:String(e);console.error("âŒ CV Worker: Failed to initialize MediaPipe:",e),this.postError(`Failed to initialize MediaPipe: ${t}`)}}async loadMediaPipeScripts(){return new Promise(async(e,t)=>{try{console.log("ðŸ“¦ CV Worker: Loading MediaPipe scripts..."),importScripts("./assets/mediapipe-worker-loader.js");const{initializeMediaPipe:t,detectForVideo:s}=await globalThis.MediaPipeWorkerLoader.loadVisionTasks();globalThis.detectForVideo=s,console.log("âœ… CV Worker: MediaPipe scripts loaded successfully"),e()}catch(e){console.error("âŒ CV Worker: Failed to load MediaPipe scripts:",e),t(e)}})}async processFrame(e){if(this.faceLandmarker&&this.isProcessing)try{const{imageData:t,timestamp:s}=e;this.frameCount++,console.log(`ðŸ” CV Worker: Processing detection frame ${this.frameCount} at timestamp ${s}`),console.log("ðŸ” CV Worker: detectForVideo available?",typeof globalThis.detectForVideo);const r=new OffscreenCanvas(t.width,t.height),a=r.getContext("2d",{willReadFrequently:!0});if(a.putImageData(t,0,0),"function"!=typeof globalThis.detectForVideo)return void console.error("âŒ CV Worker: detectForVideo function not available in worker context");console.log("ðŸŽ¯ CV Worker: Calling detectForVideo with canvas:",r.width,"x",r.height);const i=await globalThis.detectForVideo(r,s);if(console.log("ðŸŽ¯ CV Worker: detectForVideo returned:",i),i&&i.faceLandmarks&&i.faceLandmarks.length>0){const e=this.extractMetrics(i.faceLandmarks[0],s);this.frameCount%150==0&&console.log("ðŸ‘ï¸ CV Worker: Eye metrics calculated:",{blinkRate:e.blinkRate,fatigueIndex:e.fatigueIndex,earValue:e.earValue,perclosValue:e.perclosValue}),this.postMessage({type:"metrics",data:e})}else this.frameCount%300==0&&console.log("ðŸ‘¤ CV Worker: No face detected in frame");a.clearRect(0,0,r.width,r.height),this.lastFrameTime=performance.now()}catch(e){const t=e instanceof Error?e.message:String(e);console.error("âŒ CV Worker: Frame processing error:",e),this.postError(`Frame processing error: ${t}`)}else console.log("ðŸš« CV Worker: Skipping frame - faceLandmarker:",!!this.faceLandmarker,"isProcessing:",this.isProcessing)}extractMetrics(e,t){try{const s=this.getEyeLandmarks(e,"left"),r=this.getEyeLandmarks(e,"right"),a=o.calculateAverageEAR(s,r),i=this.perclosCalculator.addEARValue(a),n=(this.blinkDetector.processEAR(a,t),this.blinkDetector.getBlinkRate()),c=l.estimatePose(e),h=l.classifyPosture(c);return{blinkRate:n,fatigueIndex:this.calculateFatigueIndex({ear:a,perclos:i,blinkRate:n,posture:h}),posture:h,earValue:a,perclosValue:i,timestamp:t}}catch(e){const t=e instanceof Error?e.message:String(e);throw new Error(`Metrics extraction failed: ${t}`)}}getEyeLandmarks(e,t){return("left"===t?[33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246]:[362,382,381,380,374,373,390,249,263,466,388,387,386,385,384,398]).map(t=>e[t]).filter(Boolean)}calculateFatigueIndex(t){const{ear:s,perclos:r,blinkRate:a,posture:i}=t;let o=0;o+=Math.max(0,(.3-s)/.3*40),o+=Math.min(40,2*r);const n=Math.abs(a-15);return o+=Math.min(10,n/2),o+=i===e.GOOD?0:i===e.FORWARD?8:i===e.TILTED?5:10,Math.min(100,Math.max(0,o))}startProcessing(){this.isProcessing=!0,this.frameCount=0,this.lastFrameTime=0,this.perclosCalculator.reset(),this.blinkDetector.reset()}stopProcessing(){this.isProcessing=!1,this.postMessage({type:"stopped",data:{frameCount:this.frameCount}})}async cleanup(){this.isProcessing=!1,this.faceLandmarker&&(this.faceLandmarker.close(),this.faceLandmarker=null),this.perclosCalculator.reset(),this.blinkDetector.reset(),this.postMessage({type:"stopped",data:{message:"CV Worker cleaned up"}})}postMessage(e){self.postMessage(e)}postError(e){this.postMessage({type:"error",data:{error:e}})}}})();