(()=>{"use strict";var e,t,s,a,r={d:(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},i={};r.r(i),r.d(i,{default:()=>h}),function(e){e.GOOD="good",e.FORWARD="forward",e.TILTED="tilted",e.TOO_CLOSE="too_close",e.TOO_FAR="too_far"}(e||(e={})),function(e){e.GOOD="good",e.TIRED="tired",e.CRITICAL="critical"}(t||(t={})),function(e){e.MICRO="micro",e.SHORT="short",e.LONG="long"}(s||(s={})),function(e){e.ZAN_ZHU="zan_zhu",e.SI_BAI="si_bai",e.JING_MING="jing_ming"}(a||(a={})),Error,a.ZAN_ZHU,a.SI_BAI,a.JING_MING;class o{static calculateEAR(e){if(e.length<6)throw new Error("Insufficient eye landmarks for EAR calculation");const[t,s,a,r,i,o]=e;return(this.euclideanDistance(s,o)+this.euclideanDistance(a,i))/(2*this.euclideanDistance(t,r))}static calculateAverageEAR(e,t){return(this.calculateEAR(e)+this.calculateEAR(t))/2}static euclideanDistance(e,t){const s=e.x-t.x,a=e.y-t.y,r=e.z-t.z;return Math.sqrt(s*s+a*a+r*r)}}class n{constructor(e=30,t=.2){this.earHistory=[],this.windowSize=e,this.closureThreshold=t}addEARValue(e){return this.earHistory.push(e),this.earHistory.length>this.windowSize&&this.earHistory.shift(),this.calculatePERCLOS()}calculatePERCLOS(){return 0===this.earHistory.length?0:this.earHistory.filter(e=>e<this.closureThreshold).length/this.earHistory.length*100}reset(){this.earHistory=[]}getWindowSize(){return this.earHistory.length}}class c{constructor(e=.2,t=100,s=400){this.earHistory=[],this.blinkCount=0,this.lastBlinkTime=0,this.blinkThreshold=e,this.minBlinkDuration=t,this.maxBlinkDuration=s}processEAR(e,t){return this.earHistory.push(e),this.earHistory.length>10&&this.earHistory.shift(),!!this.detectBlinkPattern(t)&&(this.blinkCount++,this.lastBlinkTime=t,!0)}getBlinkRate(e=6e4){const t=Date.now(),s=Math.min(e,t-this.lastBlinkTime);return 0===s?0:this.blinkCount/s*6e4}reset(){this.earHistory=[],this.blinkCount=0,this.lastBlinkTime=Date.now()}detectBlinkPattern(e){if(this.earHistory.length<3)return!1;const t=this.earHistory.slice(-3),[s,a,r]=t;return s>this.blinkThreshold&&a<=this.blinkThreshold&&(void 0===r||r>this.blinkThreshold)}}class l{static estimatePose(e){const t=e[1],s=e[33],a=e[263],r=e[61],i=e[291],o=Math.abs(s.x-a.x),n=(s.x+a.x)/2,c=(t.x-n)/o,l=(s.y+a.y)/2,h=(r.y+i.y)/2,d=Math.abs(h-l),u=(t.y-l)/d,m=(a.y-s.y)/(a.x-s.x),p=Math.atan(m);return{pitch:180*u/Math.PI,yaw:180*c/Math.PI,roll:180*p/Math.PI}}static classifyPosture(t){const{pitch:s,yaw:a,roll:r}=t;return Math.abs(s)>15?s>0?e.FORWARD:e.GOOD:Math.abs(a)>20||Math.abs(r)>15?e.TILTED:e.GOOD}}const h=new class{constructor(){this.faceLandmarker=null,this.isProcessing=!1,this.lastFrameTime=0,this.frameCount=0,this.targetFPS=15,this.frameInterval=1e3/this.targetFPS,this.perclosCalculator=new n(30,.2),this.blinkDetector=new c(.2,100,400),self.addEventListener("message",this.handleMessage.bind(this))}async handleMessage(e){const{type:t,data:s}=e.data;console.log("üîß CV Worker received message:",t,s?"with data":"no data");try{switch(t){case"init":await this.initialize(s);break;case"process":await this.processFrame(s);break;case"stop":this.stopProcessing();break;case"cleanup":await this.cleanup();break;default:this.postError(`Unknown message type: ${t}`)}}catch(e){const s=e instanceof Error?e.message:String(e);this.postError(`Error handling ${t}: ${s}`)}}async initialize(e){try{console.log("üöÄ CV Worker: Initializing MediaPipe Face Landmarker..."),await this.loadMediaPipeScripts();const t=await FilesetResolver.forVisionTasks("/assets/wasm");this.faceLandmarker=await FaceLandmarker.createFromOptions(t,{baseOptions:{modelAssetPath:e.modelPath||"/assets/wasm/face_landmarker.task",delegate:"CPU"},runningMode:"VIDEO",numFaces:1,minFaceDetectionConfidence:.5,minFacePresenceConfidence:.5,minTrackingConfidence:.5,outputFaceBlendshapes:!1,outputFacialTransformationMatrixes:!1}),console.log("‚úÖ CV Worker: MediaPipe Face Landmarker initialized successfully"),this.postMessage({type:"ready",data:{message:"CV Worker initialized successfully"}})}catch(e){const t=e instanceof Error?e.message:String(e);console.error("‚ùå CV Worker: Failed to initialize MediaPipe:",e),this.postError(`Failed to initialize MediaPipe: ${t}`)}}async loadMediaPipeScripts(){return new Promise(async(e,t)=>{try{console.log("üì¶ CV Worker: Loading MediaPipe scripts..."),importScripts("/assets/mediapipe-worker-loader.js"),await globalThis.MediaPipeWorkerLoader.loadVisionTasks(),console.log("‚úÖ CV Worker: MediaPipe scripts loaded successfully"),e()}catch(e){console.error("‚ùå CV Worker: Failed to load MediaPipe scripts:",e),t(e)}})}async processFrame(e){if(!this.faceLandmarker||!this.isProcessing)return;const t=performance.now();if(!(t-this.lastFrameTime<this.frameInterval))try{const{imageData:s,timestamp:a}=e;this.frameCount++,this.frameCount%30==0&&console.log(`üìä CV Worker: Processing frame ${this.frameCount}, FPS: ${(1e3/this.frameInterval).toFixed(1)}`);const r=new OffscreenCanvas(s.width,s.height),i=r.getContext("2d");i.putImageData(s,0,0);const o=await this.faceLandmarker.detectForVideo(r,a);if(o.faceLandmarks&&o.faceLandmarks.length>0){const e=this.extractMetrics(o.faceLandmarks[0],a);console.log("üëÅÔ∏è CV Worker: Eye metrics calculated:",{blinkRate:e.blinkRate,fatigueIndex:e.fatigueIndex,earValue:e.earValue,perclosValue:e.perclosValue}),this.postMessage({type:"metrics",data:e})}else this.frameCount%60==0&&console.log("üë§ CV Worker: No face detected in frame");i.clearRect(0,0,r.width,r.height),this.lastFrameTime=t}catch(e){const t=e instanceof Error?e.message:String(e);console.error("‚ùå CV Worker: Frame processing error:",e),this.postError(`Frame processing error: ${t}`)}}extractMetrics(e,t){try{const s=this.getEyeLandmarks(e,"left"),a=this.getEyeLandmarks(e,"right"),r=o.calculateAverageEAR(s,a),i=this.perclosCalculator.addEARValue(r),n=(this.blinkDetector.processEAR(r,t),this.blinkDetector.getBlinkRate()),c=l.estimatePose(e),h=l.classifyPosture(c);return{blinkRate:n,fatigueIndex:this.calculateFatigueIndex({ear:r,perclos:i,blinkRate:n,posture:h}),posture:h,earValue:r,perclosValue:i,timestamp:t}}catch(e){const t=e instanceof Error?e.message:String(e);throw new Error(`Metrics extraction failed: ${t}`)}}getEyeLandmarks(e,t){return("left"===t?[33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246]:[362,382,381,380,374,373,390,249,263,466,388,387,386,385,384,398]).map(t=>e[t]).filter(Boolean)}calculateFatigueIndex(t){const{ear:s,perclos:a,blinkRate:r,posture:i}=t;let o=0;o+=Math.max(0,(.3-s)/.3*40),o+=Math.min(40,2*a);const n=Math.abs(r-15);return o+=Math.min(10,n/2),o+=i===e.GOOD?0:i===e.FORWARD?8:i===e.TILTED?5:10,Math.min(100,Math.max(0,o))}startProcessing(){this.isProcessing=!0,this.frameCount=0,this.lastFrameTime=0,this.perclosCalculator.reset(),this.blinkDetector.reset()}stopProcessing(){this.isProcessing=!1,this.postMessage({type:"stopped",data:{frameCount:this.frameCount}})}async cleanup(){this.isProcessing=!1,this.faceLandmarker&&(this.faceLandmarker.close(),this.faceLandmarker=null),this.perclosCalculator.reset(),this.blinkDetector.reset(),this.postMessage({type:"stopped",data:{message:"CV Worker cleaned up"}})}postMessage(e){self.postMessage(e)}postError(e){this.postMessage({type:"error",data:{error:e}})}}})();