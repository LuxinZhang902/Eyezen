{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://eyezen-chrome-extension/./background/service-worker.ts","webpack://eyezen-chrome-extension/webpack/bootstrap","webpack://eyezen-chrome-extension/webpack/runtime/chunk loaded","webpack://eyezen-chrome-extension/webpack/runtime/define property getters","webpack://eyezen-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://eyezen-chrome-extension/webpack/runtime/make namespace object","webpack://eyezen-chrome-extension/webpack/runtime/jsonp chunk loading","webpack://eyezen-chrome-extension/webpack/before-startup","webpack://eyezen-chrome-extension/webpack/startup","webpack://eyezen-chrome-extension/webpack/after-startup"],"sourcesContent":["/**\n * Background Service Worker\n * Handles alarms, notifications, and background tasks for EyeZen\n */\nimport { ChromeStorageService } from '../core/storage/index';\nimport { BreakType, DEFAULT_SETTINGS } from '../types/index';\n// Constants\nconst ALARM_NAMES = {\n    BREAK_REMINDER: 'break-reminder',\n    DAILY_SUMMARY: 'daily-summary',\n    WEEKLY_SUMMARY: 'weekly-summary',\n    POSTURE_CHECK: 'posture-check'\n};\nconst DEFAULT_INTERVALS = {\n    BREAK_REMINDER: 20, // 20 minutes for 20-20-20 rule\n    POSTURE_CHECK: 30, // 30 minutes for posture reminders\n    DAILY_SUMMARY: 24 * 60, // Daily at end of day\n    WEEKLY_SUMMARY: 7 * 24 * 60 // Weekly summary\n};\nclass BackgroundService {\n    constructor() {\n        this.isInitialized = false;\n        this.activeBreakTabId = null;\n    }\n    async initialize() {\n        if (this.isInitialized)\n            return;\n        try {\n            // Set up alarm listeners\n            chrome.alarms.onAlarm.addListener(this.handleAlarm.bind(this));\n            // Set up message listeners\n            chrome.runtime.onMessage.addListener(this.handleMessage.bind(this));\n            // Set up installation/startup listeners\n            chrome.runtime.onInstalled.addListener(this.handleInstall.bind(this));\n            chrome.runtime.onStartup.addListener(this.handleStartup.bind(this));\n            // Set up tab listeners for break management\n            chrome.tabs.onRemoved.addListener(this.handleTabRemoved.bind(this));\n            // Initialize default alarms\n            await this.setupDefaultAlarms();\n            this.isInitialized = true;\n            console.log('EyeZen Background Service initialized');\n        }\n        catch (error) {\n            console.error('Failed to initialize background service:', error);\n        }\n    }\n    async handleAlarm(alarm) {\n        console.log('Alarm triggered:', alarm.name);\n        try {\n            switch (alarm.name) {\n                case ALARM_NAMES.BREAK_REMINDER:\n                    await this.handleBreakReminder();\n                    break;\n                case ALARM_NAMES.POSTURE_CHECK:\n                    await this.handlePostureCheck();\n                    break;\n                case ALARM_NAMES.DAILY_SUMMARY:\n                    await this.handleDailySummary();\n                    break;\n                case ALARM_NAMES.WEEKLY_SUMMARY:\n                    await this.handleWeeklySummary();\n                    break;\n                default:\n                    console.log('Unknown alarm:', alarm.name);\n            }\n        }\n        catch (error) {\n            console.error('Error handling alarm:', alarm.name, error);\n        }\n    }\n    async handleMessage(message, sender, sendResponse) {\n        // Only log non-camera messages to reduce console noise\n        if (message.type !== 'REQUEST_CAMERA' && message.type !== 'STOP_CAMERA' && message.type !== 'GET_CAMERA_STATE') {\n            console.log('üîÑ Service Worker received message:', message.type || message.action, 'from:', sender.tab?.url || 'extension');\n        }\n        try {\n            // Handle camera-related messages by forwarding to offscreen document\n            if (message.type === 'REQUEST_CAMERA' || message.type === 'STOP_CAMERA' || message.type === 'GET_CAMERA_STATE') {\n                // Reduced logging for frequent camera messages\n                this.forwardToOffscreenDocument(message, sendResponse);\n                return true; // Keep message port open for async response\n            }\n            // Handle test message from popup\n            if (message.type === 'POPUP_TEST') {\n                console.log('üß™ Service Worker: Received test message from popup:', message.data);\n                sendResponse({ success: true, message: 'Test message received by service worker' });\n                return false;\n            }\n            // Handle EYE_METRICS messages from offscreen document - forward to popup and dashboard\n            if (message.type === 'EYE_METRICS') {\n                const timestamp = new Date().toISOString();\n                console.log(`üëÅÔ∏è [${timestamp}] Service Worker: Received EYE_METRICS from offscreen:`, message.data);\n                console.log(`üì§ [${timestamp}] Service Worker: Forwarding eye metrics to popup and dashboard`);\n                // Store the metrics in chrome.storage for popup to access\n                try {\n                    await chrome.storage.local.set({\n                        'latest_eye_metrics': {\n                            data: message.data,\n                            timestamp: Date.now()\n                        }\n                    });\n                    console.log(`üíæ [${timestamp}] Service Worker: Stored eye metrics in storage`);\n                }\n                catch (error) {\n                    console.log(`‚ùå [${timestamp}] Service Worker: Error storing metrics:`, error);\n                }\n                // Try to forward to extension contexts\n                chrome.runtime.sendMessage(message).catch((error) => {\n                    console.log(`‚ö†Ô∏è [${timestamp}] Service Worker: Error forwarding to popup (expected if popup closed):`, error);\n                });\n                // Also forward to any open dashboard tabs\n                this.forwardToDashboardTabs(message);\n                sendResponse({ success: true });\n                return false;\n            }\n            // Handle regular service worker actions\n            switch (message.action) {\n                case 'START_BREAK':\n                    console.log('üõë Service Worker: Starting break:', message.breakType);\n                    await this.startBreak(message.breakType);\n                    sendResponse({ success: true });\n                    break;\n                case 'END_BREAK':\n                    console.log('‚úÖ Service Worker: Ending break:', message.breakId);\n                    await this.endBreak(message.breakId);\n                    sendResponse({ success: true });\n                    break;\n                case 'UPDATE_SETTINGS':\n                    console.log('‚öôÔ∏è Service Worker: Updating settings');\n                    await this.updateSettings(message.settings);\n                    sendResponse({ success: true });\n                    break;\n                case 'GET_STATUS':\n                    const status = await this.getStatus();\n                    console.log('üìä Service Worker: Returning status');\n                    sendResponse({ success: true, data: status });\n                    break;\n                case 'SNOOZE_REMINDER':\n                    console.log('üò¥ Service Worker: Snoozing reminder for', message.minutes || 5, 'minutes');\n                    await this.snoozeReminder(message.minutes || 5);\n                    sendResponse({ success: true });\n                    break;\n                default:\n                    console.warn('‚ùì Service Worker: Unknown action:', message.action || message.type);\n                    sendResponse({ success: false, error: 'Unknown action' });\n            }\n        }\n        catch (error) {\n            console.error('‚ùå Service Worker: Error handling message:', error);\n            sendResponse({ success: false, error: String(error) });\n        }\n        return false; // Close message channel after synchronous response\n    }\n    async handleInstall(details) {\n        if (details.reason === 'install') {\n            console.log('EyeZen installed for the first time');\n            await this.setupInitialData();\n            // Show welcome notification\n            await this.showNotification({\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title: 'Welcome to EyeZen! üëÅÔ∏è',\n                message: 'Your AI eye health companion is ready. Click to get started!'\n            });\n        }\n        else if (details.reason === 'update') {\n            console.log('EyeZen updated to version:', chrome.runtime.getManifest().version);\n        }\n    }\n    async handleStartup() {\n        console.log('EyeZen service worker started');\n        await this.setupDefaultAlarms();\n    }\n    async handleTabRemoved(tabId) {\n        if (this.activeBreakTabId === tabId) {\n            this.activeBreakTabId = null;\n            console.log('Break tab closed');\n        }\n    }\n    async setupDefaultAlarms() {\n        try {\n            const userData = await ChromeStorageService.getUserData();\n            const settings = userData?.settings || DEFAULT_SETTINGS;\n            // Clear existing alarms\n            await chrome.alarms.clearAll();\n            // Set up break reminder alarm\n            if (settings.reminderEnabled ?? true) {\n                const interval = settings.reminderInterval ?? DEFAULT_INTERVALS.BREAK_REMINDER;\n                await chrome.alarms.create(ALARM_NAMES.BREAK_REMINDER, {\n                    delayInMinutes: interval,\n                    periodInMinutes: interval\n                });\n            }\n            // Set up posture check alarm\n            if (settings.reminderEnabled ?? true) {\n                await chrome.alarms.create(ALARM_NAMES.POSTURE_CHECK, {\n                    delayInMinutes: DEFAULT_INTERVALS.POSTURE_CHECK,\n                    periodInMinutes: DEFAULT_INTERVALS.POSTURE_CHECK\n                });\n            }\n            // Set up daily summary alarm (8 PM)\n            const now = new Date();\n            const dailySummaryTime = new Date();\n            dailySummaryTime.setHours(20, 0, 0, 0); // 8 PM\n            if (dailySummaryTime <= now) {\n                dailySummaryTime.setDate(dailySummaryTime.getDate() + 1);\n            }\n            await chrome.alarms.create(ALARM_NAMES.DAILY_SUMMARY, {\n                when: dailySummaryTime.getTime(),\n                periodInMinutes: DEFAULT_INTERVALS.DAILY_SUMMARY\n            });\n            console.log('Default alarms set up successfully');\n        }\n        catch (error) {\n            console.error('Failed to setup default alarms:', error);\n        }\n    }\n    async handleBreakReminder() {\n        try {\n            const userData = await ChromeStorageService.getUserData();\n            if (!userData || !userData.settings.reminderEnabled) {\n                return;\n            }\n            // Check if user is currently in a break\n            const activeBreak = userData.breaks.find(b => !b.completed);\n            if (activeBreak) {\n                console.log('User is already in a break, skipping reminder');\n                return;\n            }\n            // Check recent activity to determine reminder urgency\n            const recentMetrics = userData.metrics.slice(-5);\n            const avgEyeStrain = recentMetrics.reduce((sum, m) => sum + (m.fatigueIndex || 0), 0) / recentMetrics.length;\n            let title = 'üëÅÔ∏è Time for an Eye Break!';\n            let message = 'Follow the 20-20-20 rule: Look at something 20 feet away for 20 seconds.';\n            let priority = 0;\n            if (avgEyeStrain > 0.7) {\n                title = '‚ö†Ô∏è High Eye Strain Detected!';\n                message = 'Your eyes need immediate rest. Take a break now to prevent fatigue.';\n                priority = 2;\n            }\n            else if (avgEyeStrain > 0.5) {\n                title = 'üò¥ Eyes Getting Tired';\n                message = 'Time for a refreshing eye break. Your future self will thank you!';\n                priority = 1;\n            }\n            await this.showNotification({\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title,\n                message,\n                priority,\n                buttons: [\n                    { title: 'Start Break' },\n                    { title: 'Snooze 5min' }\n                ]\n            });\n        }\n        catch (error) {\n            console.error('Error in break reminder:', error);\n        }\n    }\n    async handlePostureCheck() {\n        try {\n            const userData = await ChromeStorageService.getUserData();\n            if (!userData || !userData.settings.reminderEnabled) {\n                return;\n            }\n            await this.showNotification({\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title: 'üßò Posture Check',\n                message: 'Sit up straight, relax your shoulders, and adjust your screen height.',\n                priority: 0\n            });\n        }\n        catch (error) {\n            console.error('Error in posture check:', error);\n        }\n    }\n    async handleDailySummary() {\n        try {\n            // Generate and show daily summary\n            const userData = await ChromeStorageService.getUserData();\n            if (!userData)\n                return;\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n            const todayMetrics = userData.metrics.filter(m => {\n                const metricDate = new Date(m.timestamp);\n                metricDate.setHours(0, 0, 0, 0);\n                return metricDate.getTime() === today.getTime();\n            });\n            const todayBreaks = userData.breaks.filter(b => {\n                const breakDate = new Date(b.startTime);\n                breakDate.setHours(0, 0, 0, 0);\n                return breakDate.getTime() === today.getTime() && b.completed;\n            });\n            const avgEyeHealth = todayMetrics.length > 0\n                ? todayMetrics.reduce((sum, m) => sum + (100 - (m.fatigueIndex || 0) * 100), 0) / todayMetrics.length\n                : 50;\n            await this.showNotification({\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title: 'üìä Daily Eye Health Summary',\n                message: `Eye Health Score: ${Math.round(avgEyeHealth)}/100 | Breaks Taken: ${todayBreaks.length}`,\n                priority: 0\n            });\n        }\n        catch (error) {\n            console.error('Error in daily summary:', error);\n        }\n    }\n    async handleWeeklySummary() {\n        try {\n            // Generate weekly summary - placeholder for now\n            await this.showNotification({\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title: 'üìà Weekly Eye Health Report',\n                message: 'Your weekly eye health report is ready! Click to view insights.',\n                priority: 1\n            });\n        }\n        catch (error) {\n            console.error('Error in weekly summary:', error);\n        }\n    }\n    async startBreak(breakType) {\n        try {\n            // Create break record\n            const breakId = Date.now().toString();\n            const breakData = {\n                id: breakId,\n                type: breakType,\n                duration: breakType === BreakType.MICRO ? 20 : breakType === BreakType.SHORT ? 300 : 900,\n                startTime: Date.now(),\n                completed: false,\n                activities: []\n            };\n            // Save break to storage\n            const userData = await ChromeStorageService.getUserData();\n            if (userData) {\n                userData.breaks.push(breakData);\n                await ChromeStorageService.saveUserData(userData);\n            }\n            // Open break ritual page\n            const breakUrl = chrome.runtime.getURL(`break-ritual.html?type=${breakType}&id=${breakId}`);\n            const tab = await chrome.tabs.create({ url: breakUrl });\n            this.activeBreakTabId = tab.id || null;\n            console.log('Break started:', breakType, breakId);\n        }\n        catch (error) {\n            console.error('Error starting break:', error);\n            throw error;\n        }\n    }\n    async endBreak(breakId) {\n        try {\n            const userData = await ChromeStorageService.getUserData();\n            if (userData) {\n                const breakIndex = userData.breaks.findIndex(b => b.id === breakId);\n                if (breakIndex !== -1) {\n                    userData.breaks[breakIndex].completed = true;\n                    userData.breaks[breakIndex].endTime = Date.now();\n                    await ChromeStorageService.saveUserData(userData);\n                }\n            }\n            console.log('Break completed:', breakId);\n        }\n        catch (error) {\n            console.error('Error ending break:', error);\n            throw error;\n        }\n    }\n    async updateSettings(settings) {\n        try {\n            await ChromeStorageService.updateSettings(settings);\n            // Recreate alarms with new settings\n            await this.setupDefaultAlarms();\n            console.log('Settings updated:', settings);\n        }\n        catch (error) {\n            console.error('Error updating settings:', error);\n            throw error;\n        }\n    }\n    async getStatus() {\n        try {\n            const userData = await ChromeStorageService.getUserData();\n            return {\n                isActive: true,\n                settings: userData?.settings || {},\n                lastBreak: userData?.breaks.slice(-1)[0] || null,\n                todayMetrics: userData?.metrics.filter(m => {\n                    const today = new Date();\n                    today.setHours(0, 0, 0, 0);\n                    const metricDate = new Date(m.timestamp);\n                    metricDate.setHours(0, 0, 0, 0);\n                    return metricDate.getTime() === today.getTime();\n                }) || []\n            };\n        }\n        catch (error) {\n            console.error('Error getting status:', error);\n            throw error;\n        }\n    }\n    async snoozeReminder(minutes) {\n        try {\n            // Clear current break reminder\n            await chrome.alarms.clear(ALARM_NAMES.BREAK_REMINDER);\n            // Set new alarm for snooze duration\n            await chrome.alarms.create(ALARM_NAMES.BREAK_REMINDER, {\n                delayInMinutes: minutes\n            });\n            console.log(`Break reminder snoozed for ${minutes} minutes`);\n        }\n        catch (error) {\n            console.error('Error snoozing reminder:', error);\n            throw error;\n        }\n    }\n    async ensureOffscreenDocument() {\n        console.log('üîç Checking for existing offscreen document...');\n        const existingContexts = await chrome.runtime.getContexts({});\n        console.log('üìã All existing contexts:', existingContexts);\n        const offscreenDocument = existingContexts.find((context) => context.contextType === 'OFFSCREEN_DOCUMENT');\n        if (!offscreenDocument) {\n            console.log('üìÑ No offscreen document found, creating new one...');\n            await chrome.offscreen.createDocument({\n                url: 'offscreen.html',\n                reasons: [chrome.offscreen.Reason.USER_MEDIA],\n                justification: 'Camera access for eye health monitoring'\n            });\n            console.log('‚úÖ Offscreen document created successfully');\n        }\n        else {\n            console.log('‚úÖ Offscreen document already exists:', offscreenDocument);\n        }\n    }\n    async forwardToOffscreenDocument(message, sendResponse) {\n        console.log('üöÄ forwardToOffscreenDocument called with message:', message);\n        try {\n            console.log('üìÑ Ensuring offscreen document exists...');\n            await this.ensureOffscreenDocument();\n            console.log('‚úÖ Offscreen document ensured');\n            // Wait a bit for offscreen document to be ready\n            console.log('‚è≥ Waiting 500ms for offscreen document to be ready...');\n            await new Promise(resolve => setTimeout(resolve, 500));\n            console.log('‚úÖ Wait completed, sending message to offscreen document');\n            // Send message directly to offscreen document\n            console.log('üì§ Sending message to offscreen document:', message);\n            chrome.runtime.sendMessage(message, (response) => {\n                console.log('üì• Received response from offscreen document:', response);\n                console.log('üîç Chrome runtime last error:', chrome.runtime.lastError);\n                if (chrome.runtime.lastError) {\n                    console.error('‚ùå Error communicating with offscreen document:', chrome.runtime.lastError);\n                    sendResponse({ success: false, error: chrome.runtime.lastError.message });\n                }\n                else {\n                    console.log('‚úÖ Forwarding response back to popup:', response);\n                    sendResponse(response);\n                }\n            });\n        }\n        catch (error) {\n            console.error('‚ùå Error in forwardToOffscreenDocument:', error);\n            sendResponse({ success: false, error: error instanceof Error ? error.message : String(error) });\n        }\n    }\n    async forwardToDashboardTabs(message) {\n        try {\n            // Query for tabs that contain the dashboard page\n            const tabs = await chrome.tabs.query({ url: '*://*/eye-posture-dashboard.html' });\n            // Also check for file:// URLs (local development)\n            const localTabs = await chrome.tabs.query({ url: 'file://*/eye-posture-dashboard.html' });\n            const allDashboardTabs = [...tabs, ...localTabs];\n            // Send message to each dashboard tab\n            for (const tab of allDashboardTabs) {\n                if (tab.id) {\n                    chrome.tabs.sendMessage(tab.id, message).catch(() => {\n                        // Ignore errors if tab is not ready or doesn't have content script\n                    });\n                }\n            }\n            if (allDashboardTabs.length > 0) {\n                console.log(`üìä Forwarded metrics to ${allDashboardTabs.length} dashboard tab(s)`);\n            }\n        }\n        catch (error) {\n            console.error('‚ùå Failed to forward message to dashboard tabs:', error);\n        }\n    }\n    async setupInitialData() {\n        try {\n            const initialData = {\n                settings: {\n                    cameraEnabled: true,\n                    detectionSensitivity: 'medium',\n                    fatigueThreshold: 70,\n                    reminderEnabled: true,\n                    reminderInterval: 20,\n                    breakDuration: 20,\n                    dataRetention: 30,\n                    metricsOnly: false,\n                    language: 'en',\n                    theme: 'light',\n                    notifications: true,\n                    sounds: true,\n                    dailyBreakGoal: 8,\n                    eyeScoreGoal: 80\n                },\n                metrics: [],\n                breaks: [],\n                events: [],\n                score: {\n                    current: 50,\n                    daily: 50,\n                    weekly: 50,\n                    trend: 'stable'\n                },\n                lastUpdated: Date.now()\n            };\n            await ChromeStorageService.saveUserData(initialData);\n            console.log('Initial data setup completed');\n        }\n        catch (error) {\n            console.error('Error setting up initial data:', error);\n        }\n    }\n    async showNotification(options) {\n        try {\n            const notificationId = `eyezen-${Date.now()}`;\n            // Set default options\n            const notificationOptions = {\n                type: 'basic',\n                iconUrl: 'assets/icons/icon-48.svg',\n                title: 'EyeZen',\n                message: '',\n                priority: 0,\n                ...options\n            };\n            // Create notification with required properties only\n            const createOptions = {\n                type: 'basic',\n                iconUrl: notificationOptions.iconUrl || 'assets/icons/icon-48.svg',\n                title: notificationOptions.title || 'EyeZen',\n                message: notificationOptions.message || ''\n            };\n            // Add optional properties if they exist\n            if (notificationOptions.buttons) {\n                createOptions.buttons = notificationOptions.buttons;\n            }\n            await chrome.notifications.create(notificationId, createOptions);\n            // Auto-clear notification after 10 seconds for low priority\n            if ((options.priority || 0) === 0) {\n                setTimeout(() => {\n                    chrome.notifications.clear(notificationId);\n                }, 10000);\n            }\n        }\n        catch (error) {\n            console.error('Error showing notification:', error);\n        }\n    }\n}\n// Initialize the background service\nconst backgroundService = new BackgroundService();\nbackgroundService.initialize();\n// Handle notification clicks\nchrome.notifications.onClicked.addListener((notificationId) => {\n    if (notificationId.startsWith('eyezen-')) {\n        // Open popup or options page\n        chrome.action.openPopup();\n        chrome.notifications.clear(notificationId);\n    }\n});\n// Handle notification button clicks\nchrome.notifications.onButtonClicked.addListener((notificationId, buttonIndex) => {\n    if (notificationId.startsWith('eyezen-')) {\n        if (buttonIndex === 0) {\n            // Start Break button\n            backgroundService.initialize().then(() => {\n                chrome.runtime.sendMessage({ action: 'START_BREAK', breakType: BreakType.SHORT });\n            });\n        }\n        else if (buttonIndex === 1) {\n            // Snooze button\n            backgroundService.initialize().then(() => {\n                chrome.runtime.sendMessage({ action: 'SNOOZE_REMINDER', minutes: 5 });\n            });\n        }\n        chrome.notifications.clear(notificationId);\n    }\n});\nexport default backgroundService;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"background\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkeyezen_chrome_extension\"] = self[\"webpackChunkeyezen_chrome_extension\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"core_storage_index_ts\"], () => (__webpack_require__(\"./background/service-worker.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}